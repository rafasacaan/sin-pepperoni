[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "about",
    "section": "",
    "text": "Hello, my name is Rafa, and this is the sin-pepperoni blog.\nI started off as an electrical engineer, then deep-dived into math and optimization to tackle questions about electrical power systems, and eventually earned an MSc in operations research and data science.\nSince then, I‚Äôve been collaborating as a data scientist, putting questions at the heart of my work, and leveraging the toolbox I‚Äôve gathered along my journey to answer them.\nFeel free to connect and thank you for reading!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "sin pepperoni",
    "section": "",
    "text": "Hello! üëã\nExploring curiosity is like ordering a pizza without pepperoni ‚Äîit‚Äôs about embracing different flavors and trying new things.\nJust as a pizza without pepperoni opens up a world of possibilities, staying curious opens doors to endless discoveries and adventures.\n\n[Work in progress!]   \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome to the blog\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nFeb 7, 2024\n\n\n1 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome to the blog",
    "section": "",
    "text": "This is the first test post. Welcome!\n\n\ndasdnkadnkncx nksac as\n\n\n\nasdlsadnlaskdnsaldnlsakndlksadnlak"
  },
  {
    "objectID": "posts/welcome/index.html#more-things-to-do",
    "href": "posts/welcome/index.html#more-things-to-do",
    "title": "Welcome to the blog",
    "section": "",
    "text": "dasdnkadnkncx nksac as"
  },
  {
    "objectID": "posts/welcome/index.html#and-yet-more",
    "href": "posts/welcome/index.html#and-yet-more",
    "title": "Welcome to the blog",
    "section": "",
    "text": "asdlsadnlaskdnsaldnlsakndlksadnlak"
  },
  {
    "objectID": "posts/post-with-code/sentinel.html",
    "href": "posts/post-with-code/sentinel.html",
    "title": "Geo experimentation #1",
    "section": "",
    "text": "A first approach to playing with Sentinel images."
  },
  {
    "objectID": "posts/post-with-code/sentinel.html#pick-a-spot-and-find-its-boundary-data",
    "href": "posts/post-with-code/sentinel.html#pick-a-spot-and-find-its-boundary-data",
    "title": "Geo experimentation #1",
    "section": "Pick a spot and find its boundary data",
    "text": "Pick a spot and find its boundary data\nWe will first load from OSMNx library the political boundaries of a target spot.\n\n\nCode\nimport osmnx as ox \nimport matplotlib.pyplot as plt\n\nprint(\"osmnx version: \", ox.__version__)\n\n\nosmnx version:  1.9.2\n\n\n\n\nCode\ncity = 'Valdivia'\nadmin = ox.geocode_to_gdf(city)\nadmin.plot();\n\n\n\n\n\n\n\n\n\nLet¬¥s build a convex hull from the above polygon, so we can get a cleaner search area.\n\n\nCode\nadmin_polygon = admin.convex_hull.geometry.to_list()[0]\nadmin_polygon"
  },
  {
    "objectID": "posts/post-with-code/sentinel.html#find-satellite-data",
    "href": "posts/post-with-code/sentinel.html#find-satellite-data",
    "title": "Geo experimentation #1",
    "section": "Find satellite data",
    "text": "Find satellite data\nWe need satellite data to support any analysis on data. Here is a list for the top satellite maps in 2024: - Satellite maps sources\nSentinel images is a good option! There are six Sentinel missions, where three can be accessed through its API. Let¬¥s check the description for each set of images:\n\nSentinel-1\n\nApplications: Sentinel-1 is used for monitoring changes in land cover, detecting deforestation, mapping floods, monitoring sea ice, and supporting maritime surveillance.\nInformation: Sentinel-1 is a radar imaging satellite that provides all-weather, day-and-night radar imagery.\nResolution: Sentinel-1 offers various resolution modes, including: Interferometric Wide swath mode (IW): 5 m x 20 m (VV and VH polarizations) Extra Wide swath mode (EW): 20 m x 40 m (HH polarization)\nStripmap mode (SM): 5 m x 5 m (VV and VH polarizations)\n\n\n\nSentinel-2\n\nInformation: Sentinel-2 is a multispectral optical imaging satellite, providing high-resolution imagery in 13 spectral bands.\nResolution: Sentinel-2 offers the following spatial resolutions:\n\n10 meters for the visible and near-infrared bands\n20 meters for the red edge and shortwave infrared bands\n60 meters for the atmospheric and water vapor bands\n\nApplications: Sentinel-2 is widely used for monitoring agriculture, forestry, land cover changes, urban planning, and environmental monitoring.\n\n\n\nSentinel-3:\n\nInformation: Sentinel-3 is a multi-instrument satellite mission designed for oceanographic and land monitoring applications.\nResolution: Sentinel-3 provides different resolution characteristics depending on the instrument:\n\nSea and Land Surface Temperature Radiometer (SLSTR): Spatial resolution varies from 500 m to 1 km\nOcean and Land Colour Instrument (OLCI): Spatial resolution ranges from 300 m to 1 km\nSynthetic Aperture Radar Altimeter (SRAL): Spatial resolution is around 300 m over the ocean\n\nApplications: Sentinel-3 is primarily used for monitoring ocean ecosystems, sea surface temperature, ocean color, sea level changes, land surface temperature, and vegetation health.\n\nLet¬¥s use Sentinel-2 images! We can use the sentinelsat library and can download images after authentication.\n\n\nCode\nimport sentinelsat\nprint(\"sentinelsat version: \", sentinelsat.__version__)\n\nfrom sentinelsat import SentinelAPI, read_geojson, geojson_to_wkt\n\n\nsentinelsat version:  1.2.1\n\n\n\n\nCode\n user = &lt;add your user name&gt;\npassword = &lt; add your password &gt;\napi = SentinelAPI(user, password, 'https://apihub.copernicus.eu/apihub') \n\n\nYou can query the API by specifying the polygon area, range of dates, which sentinel data and cloud coverage properties.\n\n\nCode\n# location (based on a polygon)\n# the time frame\n# the space probe\n# and the level of cloud-coverage accepted \n\nproducts = api.query(admin_polygon,\n                     date=('20150623', '20231006'),\n                     platformname='Sentinel-2',\n                     cloudcoverpercentage=(0, 100))\n\nlen(products)"
  },
  {
    "objectID": "posts/geospatial_data/sentinel copy.html",
    "href": "posts/geospatial_data/sentinel copy.html",
    "title": "Descargando im√°genes satelitales desde Sentinel Hub con python",
    "section": "",
    "text": "Mi primer acercamiento a im√°genes satelitales.\nHace poco tiempo descubr√≠ Sentinel Hub (https://www.sentinel-hub.com/), que seg√∫n sus propias palabras se definen como:\nPerfeeecto. Entonces, aparte de ofrecernos una plataforma para el procesamiento de im√°genes, nos ofrece f√°cil acceso a una extensa colecci√≥n de im√°genes. Tremendo. Pero esto no puede ser gratis‚Ä¶ o s√≠?\nPara el plan gratuito, tenemos 5,000 processing units (PUs) o requests a la API al mes, o 300 por minuto. Qu√© es un PU? Una im√°gen de 512x512, 16 bits y 3 bandas cuesta un PU, aproximadamente."
  },
  {
    "objectID": "posts/geospatial_data/sentinel copy.html#paso-1-instalaci√≥n-y-autenticaci√≥n",
    "href": "posts/geospatial_data/sentinel copy.html#paso-1-instalaci√≥n-y-autenticaci√≥n",
    "title": "Descargando im√°genes satelitales desde Sentinel Hub con python",
    "section": "Paso #1: instalaci√≥n y autenticaci√≥n",
    "text": "Paso #1: instalaci√≥n y autenticaci√≥n\nPrimero, necesitamos crear una cuenta en Sentinel Hub e instalar la librer√≠a para acceder a la API. Para lo primero, crea un usuario en la p√°gina, y luego clickea en Account Settings. Luego, tienes que crear un cliente para poder consultar la API (OAuth client), donde obtendr√°s un usuario y clave.\n\n\n\nOAuth client de la API.\n\n\nAhora, necesitamos instalar el paquete de python de sentinel hub:\npip install sentinelhub\n\nAuthenticate\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\n\n\nCode\nfrom sentinelhub import SHConfig\n\nclient_secret = \"2q0hrUeD6QSELMvyWhxADiBHLKianGvP\"\nclient_id = \"ef03eb3d-e59f-4137-aecf-fae1eac611c7\"\n\nconfig = SHConfig(sh_client_id = client_id, sh_client_secret = client_secret)\n\n\n\n\nCreate functions to retrieve images and plot\n\n\nCode\nfrom sentinelhub import (\n    CRS,\n    BBox,\n    DataCollection,\n    #DownloadRequest,\n    MimeType,\n    MosaickingOrder,\n    #SentinelHubDownloadClient,\n    SentinelHubRequest,\n    bbox_to_dimensions,\n)\n\n\n\n\nCode\ndef download_image(\n    target_area_coords: tuple, \n    resolution: int\n):\n    \"\"\"\n    Download image from Sentinel Hub.\n    \n    Params:\n    -------\n        target_area_coords: long/lat pairs for upper left and lower right vertices \n            of bounding box\n        \n    \"\"\"\n\n    # define the bounding box object\n    target_bbox = BBox(bbox=target_area_coords, crs=CRS.WGS84)\n    target_size = bbox_to_dimensions(target_bbox, resolution=resolution)\n    print('The image\\'s size at ' + str(resolution) + ' resolution: ',  target_size)\n    \n    # define the query\n    evalscript_true_color = \"\"\"\n        //VERSION=3\n\n        function setup() {\n            return {\n                input: [{\n                    bands: [\"B02\", \"B03\", \"B04\"]\n                }],\n                output: {\n                    bands: 3\n                }\n            };\n        }\n\n        function evaluatePixel(sample) {\n            return [sample.B04, sample.B03, sample.B02];\n        }\n    \"\"\"\n\n    # run api call\n    request_true_color = SentinelHubRequest(\n                evalscript=evalscript_true_color,\n                input_data=[\n                    SentinelHubRequest.input_data(\n                        data_collection=DataCollection.SENTINEL2_L1C,\n                        time_interval=(\"2023-01-01\", \"2024-01-01\"),\n                        mosaicking_order=MosaickingOrder.LEAST_CC,\n                    )\n                ],\n                responses=[SentinelHubRequest.output_response(\"default\", MimeType.PNG)],\n                bbox=target_bbox,\n                size=target_size,\n                config=config,\n            )\n\n    # Get data\n    true_color_imgs = request_true_color.get_data()\n    image = true_color_imgs[0]\n    \n    # Print image size    \n    size_in_bytes = image.nbytes\n    size_in_mb = size_in_bytes / (1024 * 1024)\n    print(f\"Size of the NumPy array: {size_in_mb: .2f} MB\")\n    \n    return image\n\n    \ndef plot_image(image: np.array):\n    \n    f, ax = plt.subplots(1,1,figsize=(10,10))\n    factor=2.0 / 255\n    clip_range=(0, 200)\n    ax.imshow(np.clip(image * factor, *clip_range))\n    ax.axis('off')\n    \n\n\n\n\nCode\n%%time\n\n# Define bbox\ntarget_area_coords = (-73.15480000852375,-50.376712087300675,-72.92235409436927, -50.52489277557761)\nresolution = 10\n\n# Download image\nperito_img = download_image(target_area_coords, resolution)\n\n# Plot image\nplot_image(perito_img)\n\n\nNameError: name 'BBox' is not defined\n\n\n\n\nCode\n%%time\n\n# Define bbox\ntarget_area_coords = (72.70900633500187, 3.032187530924483 , 73.12923489370033, 2.6351608765294827)\nresolution = 20\n\n# Download image\nmaldives_img = download_image(target_area_coords, resolution)\n\n# Plot image\nplot_image(maldives_img)\n\n\nThe image's size at 20 resolution:  (2341, 2191)\nSize of the NumPy array:  14.67 MB\nCPU times: user 219 ms, sys: 152 ms, total: 371 ms\nWall time: 18.3 s\n\n\nClipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).\n\n\n\n\n\n\n\n\n\n\n\nCode\n%%time\n\n# Define bbox\ntarget_area_coords = (-70.86578, -29.98710, -70.80273, -30.02864)\nresolution = 10\n\n# Download image\npuclaro_img = download_image(target_area_coords, resolution)\n\n# Plot image\nplot_image(puclaro_img)\n\n\nThe image's size at 10 resolution:  (601, 470)\nSize of the NumPy array:  0.81 MB\nCPU times: user 50 ms, sys: 19.8 ms, total: 69.8 ms\nWall time: 5.36 s\n\n\n\n\n\n\n\n\n\n\n\nCreate time lapse\n\n\nCode\ndef download_and_save_image(\n    target_area_coords: tuple,\n    resolution: int,\n    year: int,\n    month: int,\n    foldout: str,\n    location_name: str,\n):\n    \"\"\"\n    Download and save an image from Sentinel Hub.\n\n    Parameters:\n    -----------\n    target_area_coords : tuple\n        Long/lat pairs for upper left and lower right vertices of bounding box.\n    resolution : int\n        Resolution of the image to be downloaded.\n    year : int\n        Year of the image.\n    month : int\n        Month of the image.\n    foldout : str\n        Path to the directory where the image will be saved.\n    location_name : str\n        Name of the location for identification.\n\n    Returns:\n    --------\n    np.ndarray\n        The downloaded image as a NumPy array.\n\n    Raises:\n    -------\n    RuntimeError\n        If the image file already exists.\n\n    \"\"\"\n    \n    # Create directory to store the images\n    if not os.path.exists(foldout):\n        os.makedirs(foldout)\n    \n    # Get month names\n    timestamp = year * 100 + month\n    frame_file  = str(timestamp) + \"_\" + location_name + \".png\"\n\n\n    if not os.path.exists(frame_file):        \n        # Define bbox\n        target_bbox = BBox(bbox=target_area_coords, crs=CRS.WGS84)\n        target_size = bbox_to_dimensions(target_bbox, resolution=resolution)\n\n        # Create query\n        evalscript_true_color = \"\"\"\n            //VERSION=3\n\n            function setup() {\n                return {\n                    input: [{\n                        bands: [\"B02\", \"B03\", \"B04\"]\n                    }],\n                    output: {\n                        bands: 3\n                    }\n                };\n            }\n\n            function evaluatePixel(sample) {\n                return [sample.B04, sample.B03, sample.B02];\n            }\n        \"\"\"\n\n        # Call API\n        date_since = str(year) + \"-\" + str(month) + \"-01\"\n        date_until = str(year) + \"-\" + str(month) + \"-28\"\n        \n        request_true_color = SentinelHubRequest(\n                    evalscript=evalscript_true_color,\n                    input_data=[\n                        SentinelHubRequest.input_data(\n                            data_collection=DataCollection.SENTINEL2_L1C,\n                            time_interval=(date_since, date_until),\n                            mosaicking_order=MosaickingOrder.LEAST_CC,\n                        )\n                    ],\n                    responses=[SentinelHubRequest.output_response(\"default\", MimeType.PNG)],\n                    bbox=target_bbox,\n                    size=target_size,\n                    config=config,\n                )\n        \n        # # Extract image RGB channels\n        # true_color_imgs = request_true_color.get_data()\n        # image = true_color_imgs[0].astype(np.uint8)\n        \n        # Extract image RGB channels\n        try:\n            true_color_imgs = request_true_color.get_data()\n        except Exception as e:\n            raise RuntimeError(f\"Failed to retrieve image data: {e}\")\n\n        image = true_color_imgs[0].astype(np.uint8)\n                \n        # Create plot and save\n        f, ax = plt.subplots(1,1,figsize=(10,10))\n        factor=2.0 / 255\n        clip_range=(0, 200)\n        ax.imshow(np.clip(image * factor, *clip_range))\n        ax.axis('off')\n        \n        ax.annotate(\n            timestamp, \n            xy=(0.0125, 0.967), \n            xycoords='axes fraction', \n            ha='left', va='center',\n            bbox=dict(boxstyle='round', alpha=0.0), \n            fontsize=26, \n            color='w'\n        )\n        plt.savefig(foldout + '/' + frame_file, dpi=200, bbox_inches='tight')\n        plt.tight_layout()\n        plt.close()\n        \n        print(f\"Image {frame_file} has been saved.\")\n        return image\n\n\n\n\nCode\n%%time\n\n# Define bbox for Embalse Puclaro\nfoldout = \"frames\"\nlocation_name = \"puclaro\"\ntarget_area_coords = (-70.86578, -29.98710, -70.80273, -30.02864)\nresolution = 10\n\n# Get images for each month of the looped years\nfor year in range(2016, 2025):\n    for month in range(1,13):    \n        if year == 2024:\n            if month &lt; 4:\n                download_and_save_image(target_area_coords, resolution, year, month, foldout, location_name)\n        else:\n            download_and_save_image(target_area_coords, resolution, year, month, foldout, location_name)\n\n\nClipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).\nClipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).\nClipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).\nClipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).\nClipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).\n\n\nImage 201601_puclaro.png has been saved.\nImage 201602_puclaro.png has been saved.\nImage 201603_puclaro.png has been saved.\nImage 201604_puclaro.png has been saved.\nImage 201605_puclaro.png has been saved.\nImage 201606_puclaro.png has been saved.\nImage 201607_puclaro.png has been saved.\nImage 201608_puclaro.png has been saved.\nImage 201609_puclaro.png has been saved.\nImage 201610_puclaro.png has been saved.\nImage 201611_puclaro.png has been saved.\nImage 201612_puclaro.png has been saved.\nImage 201701_puclaro.png has been saved.\nImage 201702_puclaro.png has been saved.\nImage 201703_puclaro.png has been saved.\nImage 201704_puclaro.png has been saved.\nImage 201705_puclaro.png has been saved.\nImage 201706_puclaro.png has been saved.\nImage 201707_puclaro.png has been saved.\nImage 201708_puclaro.png has been saved.\nImage 201709_puclaro.png has been saved.\nImage 201710_puclaro.png has been saved.\nImage 201711_puclaro.png has been saved.\nImage 201712_puclaro.png has been saved.\nImage 201801_puclaro.png has been saved.\nImage 201802_puclaro.png has been saved.\nImage 201803_puclaro.png has been saved.\nImage 201804_puclaro.png has been saved.\nImage 201805_puclaro.png has been saved.\nImage 201806_puclaro.png has been saved.\nImage 201807_puclaro.png has been saved.\nImage 201808_puclaro.png has been saved.\nImage 201809_puclaro.png has been saved.\nImage 201810_puclaro.png has been saved.\nImage 201811_puclaro.png has been saved.\nImage 201812_puclaro.png has been saved.\nImage 201901_puclaro.png has been saved.\nImage 201902_puclaro.png has been saved.\nImage 201903_puclaro.png has been saved.\nImage 201904_puclaro.png has been saved.\nImage 201905_puclaro.png has been saved.\nImage 201906_puclaro.png has been saved.\nImage 201907_puclaro.png has been saved.\nImage 201908_puclaro.png has been saved.\nImage 201909_puclaro.png has been saved.\nImage 201910_puclaro.png has been saved.\nImage 201911_puclaro.png has been saved.\nImage 201912_puclaro.png has been saved.\nImage 202001_puclaro.png has been saved.\nImage 202002_puclaro.png has been saved.\nImage 202003_puclaro.png has been saved.\nImage 202004_puclaro.png has been saved.\nImage 202005_puclaro.png has been saved.\nImage 202006_puclaro.png has been saved.\nImage 202007_puclaro.png has been saved.\nImage 202008_puclaro.png has been saved.\nImage 202009_puclaro.png has been saved.\nImage 202010_puclaro.png has been saved.\nImage 202011_puclaro.png has been saved.\nImage 202012_puclaro.png has been saved.\nImage 202101_puclaro.png has been saved.\nImage 202102_puclaro.png has been saved.\nImage 202103_puclaro.png has been saved.\nImage 202104_puclaro.png has been saved.\nImage 202105_puclaro.png has been saved.\nImage 202106_puclaro.png has been saved.\nImage 202107_puclaro.png has been saved.\nImage 202108_puclaro.png has been saved.\nImage 202109_puclaro.png has been saved.\nImage 202110_puclaro.png has been saved.\nImage 202111_puclaro.png has been saved.\nImage 202112_puclaro.png has been saved.\nImage 202201_puclaro.png has been saved.\nImage 202202_puclaro.png has been saved.\nImage 202203_puclaro.png has been saved.\nImage 202204_puclaro.png has been saved.\nImage 202205_puclaro.png has been saved.\nImage 202206_puclaro.png has been saved.\nImage 202207_puclaro.png has been saved.\nImage 202208_puclaro.png has been saved.\nImage 202209_puclaro.png has been saved.\nImage 202210_puclaro.png has been saved.\nImage 202211_puclaro.png has been saved.\nImage 202212_puclaro.png has been saved.\nImage 202301_puclaro.png has been saved.\nImage 202302_puclaro.png has been saved.\nImage 202303_puclaro.png has been saved.\nImage 202304_puclaro.png has been saved.\nImage 202305_puclaro.png has been saved.\nImage 202306_puclaro.png has been saved.\nImage 202307_puclaro.png has been saved.\nImage 202308_puclaro.png has been saved.\nImage 202309_puclaro.png has been saved.\nImage 202310_puclaro.png has been saved.\nImage 202311_puclaro.png has been saved.\nImage 202312_puclaro.png has been saved.\nImage 202401_puclaro.png has been saved.\nImage 202402_puclaro.png has been saved.\nImage 202403_puclaro.png has been saved.\nCPU times: user 1min 19s, sys: 4.73 s, total: 1min 24s\nWall time: 9min 53s\n\n\nEnsemble images as animation\n\n\nCode\nfrom PIL import Image\n\npng_files = [f for f in os.listdir(foldout) if f.endswith('.png')]\npng_files.sort()\nframes = []\n\nfor png_file in png_files:\n    file_path = os.path.join(foldout, png_file)\n    img = Image.open(file_path)\n    frames.append(img)\n\noutput_gif_path = 'footage_complete.gif'\n\nframes[0].save(\n    output_gif_path,\n    save_all=True,\n    append_images=frames[1:],\n    duration=200,  # Set the duration between frames in milliseconds\n    loop=1         # Set loop to 0 for an infinite loop, or any positive integer for a finite loop\n)\n\n\n['201602_puclaro.png',\n '201603_puclaro.png',\n '201607_puclaro.png',\n '201608_puclaro.png',\n '201609_puclaro.png',\n '201611_puclaro.png',\n '201612_puclaro.png',\n '201701_puclaro.png',\n '201702_puclaro.png',\n '201703_puclaro.png',\n '201704_puclaro.png',\n '201705_puclaro.png',\n '201706_puclaro.png',\n '201707_puclaro.png',\n '201708_puclaro.png',\n '201709_puclaro.png',\n '201710_puclaro.png',\n '201711_puclaro.png',\n '201712_puclaro.png',\n '201801_puclaro.png',\n '201802_puclaro.png',\n '201803_puclaro.png',\n '201804_puclaro.png',\n '201805_puclaro.png',\n '201806_puclaro.png',\n '201807_puclaro.png',\n '201808_puclaro.png',\n '201809_puclaro.png',\n '201810_puclaro.png',\n '201811_puclaro.png',\n '201812_puclaro.png',\n '201901_puclaro.png',\n '201902_puclaro.png',\n '201903_puclaro.png',\n '201904_puclaro.png',\n '201905_puclaro.png',\n '201906_puclaro.png',\n '201907_puclaro.png',\n '201908_puclaro.png',\n '201909_puclaro.png',\n '201910_puclaro.png',\n '201911_puclaro.png',\n '201912_puclaro.png',\n '202001_puclaro.png',\n '202002_puclaro.png',\n '202003_puclaro.png',\n '202005_puclaro.png',\n '202006_puclaro.png',\n '202007_puclaro.png',\n '202008_puclaro.png',\n '202009_puclaro.png',\n '202010_puclaro.png',\n '202011_puclaro.png',\n '202012_puclaro.png',\n '202101_puclaro.png',\n '202102_puclaro.png',\n '202103_puclaro.png',\n '202104_puclaro.png',\n '202105_puclaro.png',\n '202106_puclaro.png',\n '202107_puclaro.png',\n '202108_puclaro.png',\n '202109_puclaro.png',\n '202110_puclaro.png',\n '202111_puclaro.png',\n '202112_puclaro.png',\n '202201_puclaro.png',\n '202202_puclaro.png',\n '202203_puclaro.png',\n '202204_puclaro.png',\n '202205_puclaro.png',\n '202206_puclaro.png',\n '202207_puclaro.png',\n '202208_puclaro.png',\n '202209_puclaro.png',\n '202210_puclaro.png',\n '202211_puclaro.png',\n '202212_puclaro.png',\n '202301_puclaro.png',\n '202302_puclaro.png',\n '202303_puclaro.png',\n '202304_puclaro.png',\n '202305_puclaro.png',\n '202306_puclaro.png',\n '202307_puclaro.png',\n '202308_puclaro.png',\n '202309_puclaro.png',\n '202310_puclaro.png',\n '202311_puclaro.png',\n '202312_puclaro.png',\n '202401_puclaro.png',\n '202402_puclaro.png',\n '202403_puclaro.png']\n\n\nAdd crossfading between frames\n\n\nCode\n%%time \n\nfrom PIL import Image, ImageDraw\n\npng_files = [f for f in os.listdir(foldout) if f.endswith('.png')]\npng_files.sort()\nframes = []\n\nfor png_file in png_files:\n    file_path = os.path.join(foldout, png_file)\n    img = Image.open(file_path)\n    frames.append(img)\n\n# Define the duration for each frame in milliseconds\nframe_duration = 60\n\n# Define the number of frames for the crossfade transition\ncrossfade_frames = 6\n\n# Create a list to store the crossfaded frames\ncrossfaded_frames = []\n\n# Iterate through pairs of consecutive frames\nfor i in range(len(frames) - 1):\n    # Extract current and next frames\n    current_frame = frames[i]\n    next_frame = frames[i + 1]\n\n    # Create a sequence of crossfaded frames between the current and next frames\n    for j in range(crossfade_frames + 1):\n        # Calculate the alpha value for blending\n        alpha = j / crossfade_frames\n\n        # Blend the current and next frames using alpha blending\n        blended_frame = Image.blend(current_frame, next_frame, alpha)\n\n        # Append the blended frame to the list of crossfaded frames\n        crossfaded_frames.append(blended_frame)\n\n# Add the last frame without crossfading\ncrossfaded_frames.append(frames[-1])\noutput_gif_path = 'footage_complete_2.gif'\n\n# Save the GIF with crossfaded frames\ncrossfaded_frames[0].save(\n    output_gif_path,\n    save_all=True,\n    append_images=crossfaded_frames[1:],\n    duration=frame_duration,  # Set the duration between frames in milliseconds\n    loop=0  # Set loop to 0 for an infinite loop, or any positive integer for a finite loop\n)\n\n\nCPU times: user 37.5 s, sys: 2.34 s, total: 39.8 s\nWall time: 40.8 s"
  },
  {
    "objectID": "posts/geospatial_data/sentinel copy.html#pick-a-spot-and-find-its-boundary-data",
    "href": "posts/geospatial_data/sentinel copy.html#pick-a-spot-and-find-its-boundary-data",
    "title": "Descargando im√°genes satelitales desde Sentinel Hub con python",
    "section": "Pick a spot and find its boundary data",
    "text": "Pick a spot and find its boundary data\nWe will first load from OSMNx library the political boundaries of a target spot.\n\n\nCode\nimport osmnx as ox \nimport matplotlib.pyplot as plt\n\nprint(\"osmnx version: \", ox.__version__)\n\n\nosmnx version:  1.9.2\n\n\n\n\nCode\ncity = 'Valdivia'\nadmin = ox.geocode_to_gdf(city)\nadmin.plot();\n\n\n\n\n\n\n\n\n\nLet¬¥s build a convex hull from the above polygon, so we can get a cleaner search area.\n\n\nCode\nadmin_polygon = admin.convex_hull.geometry.to_list()[0]\nadmin_polygon"
  },
  {
    "objectID": "posts/geospatial_data/sentinel copy.html#find-satellite-data",
    "href": "posts/geospatial_data/sentinel copy.html#find-satellite-data",
    "title": "Descargando im√°genes satelitales desde Sentinel Hub con python",
    "section": "Find satellite data",
    "text": "Find satellite data\nWe need satellite data to support any analysis on data. Here is a list for the top satellite maps in 2024: - Satellite maps sources\nSentinel images is a good option! There are six Sentinel missions, where three can be accessed through its API. Let¬¥s check the description for each set of images:\n\nSentinel-1\n\nApplications: Sentinel-1 is used for monitoring changes in land cover, detecting deforestation, mapping floods, monitoring sea ice, and supporting maritime surveillance.\nInformation: Sentinel-1 is a radar imaging satellite that provides all-weather, day-and-night radar imagery.\nResolution: Sentinel-1 offers various resolution modes, including: Interferometric Wide swath mode (IW): 5 m x 20 m (VV and VH polarizations) Extra Wide swath mode (EW): 20 m x 40 m (HH polarization)\nStripmap mode (SM): 5 m x 5 m (VV and VH polarizations)\n\n\n\nSentinel-2\n\nInformation: Sentinel-2 is a multispectral optical imaging satellite, providing high-resolution imagery in 13 spectral bands.\nResolution: Sentinel-2 offers the following spatial resolutions:\n\n10 meters for the visible and near-infrared bands\n20 meters for the red edge and shortwave infrared bands\n60 meters for the atmospheric and water vapor bands\n\nApplications: Sentinel-2 is widely used for monitoring agriculture, forestry, land cover changes, urban planning, and environmental monitoring.\n\n\n\nSentinel-3:\n\nInformation: Sentinel-3 is a multi-instrument satellite mission designed for oceanographic and land monitoring applications.\nResolution: Sentinel-3 provides different resolution characteristics depending on the instrument:\n\nSea and Land Surface Temperature Radiometer (SLSTR): Spatial resolution varies from 500 m to 1 km\nOcean and Land Colour Instrument (OLCI): Spatial resolution ranges from 300 m to 1 km\nSynthetic Aperture Radar Altimeter (SRAL): Spatial resolution is around 300 m over the ocean\n\nApplications: Sentinel-3 is primarily used for monitoring ocean ecosystems, sea surface temperature, ocean color, sea level changes, land surface temperature, and vegetation health.\n\nLet¬¥s use Sentinel-2 images! We can use the sentinelsat library and can download images after authentication.\n\n\nCode\nfrom sentinelhub import SHConfig\n\n#client_secret = 'GEZixbNoqGcFYiFMNSLz74HrzN03rfvi'\n#client_id = '10e7a03e-5783-413f-a5ba-3e1a452ce742'\n\nclient_secret = \"2q0hrUeD6QSELMvyWhxADiBHLKianGvP\"\nclient_id = \"ef03eb3d-e59f-4137-aecf-fae1eac611c7\"\n\nconfig = SHConfig(sh_client_id = client_id, sh_client_secret = client_secret)\n\n\n\n\nCode\nimport sentinelsat\nprint(\"sentinelsat version: \", sentinelsat.__version__)\n\nfrom sentinelsat import SentinelAPI, read_geojson, geojson_to_wkt\n\n\nsentinelsat version:  1.2.1\n\n\n\n\nCode\nuser = \"8410ee66-5680-4948-94ee-1051e60a7cdd\"\npassword = \"Av_.!H3rJGw5MCc\"\napi = SentinelAPI(user, password, 'https://apihub.copernicus.eu/apihub') \n\n\nYou can query the API by specifying the polygon area, range of dates, which sentinel data and cloud coverage properties.\n\n\nCode\n# location (based on a polygon)\n# the time frame\n# the space probe\n# and the level of cloud-coverage accepted \n\nproducts = api.query(\n    admin_polygon,\n    #date=('20150623', '20231006'),\n    date=('20230623', '20230723'),\n    platformname='Sentinel-2',\n    cloudcoverpercentage=(0, 100)\n)\n\nlen(products)\n\n\nConnectTimeout: HTTPSConnectionPool(host='apihub.copernicus.eu', port=443): Max retries exceeded with url: /apihub/search?format=json&rows=100&start=0&q=beginPosition%3A%5B%222023-06-23T00%3A00%3A00Z%22+TO+%222023-07-23T00%3A00%3A00Z%22%5D+cloudcoverpercentage%3A%5B%220%22+TO+%22100%22%5D+platformname%3A%22Sentinel-2%22+footprint%3A%22Intersects%28POLYGON+%28%28-73.0818064+-40.0320178%2C+-73.0825359+-40.0319356%2C+-73.10659+-40.023901%2C+-73.1442278+-40.0089817%2C+-73.1454724+-40.0084722%2C+-73.4075993+-39.8818511%2C+-73.410775+-39.8790189%2C+-73.4139412+-39.871497%2C+-73.4114492+-39.7158156%2C+-73.404981+-39.6940462%2C+-73.4049395+-39.6939276%2C+-73.4021795+-39.6909947%2C+-73.4021044+-39.6909163%2C+-73.3607501+-39.656072%2C+-73.3600581+-39.655597%2C+-73.3304465+-39.6404608%2C+-73.3230436+-39.6374307%2C+-73.3226037+-39.6373398%2C+-73.3210373+-39.6370796%2C+-73.2834452+-39.6432413%2C+-73.2429331+-39.6499494%2C+-73.0229319+-39.6924461%2C+-72.9732102+-39.7974574%2C+-72.9230207+-39.9296844%2C+-72.9220122+-39.9348509%2C+-72.9208535+-39.9412673%2C+-73.0809706+-40.0317574%2C+-73.0818064+-40.0320178%29%29%29%22 (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPSConnection object at 0x15b635e80&gt;, 'Connection to apihub.copernicus.eu timed out. (connect timeout=None)'))"
  },
  {
    "objectID": "posts/geospatial_data/sentinel copy.html#explore-list-of-products-to-a-dataframe",
    "href": "posts/geospatial_data/sentinel copy.html#explore-list-of-products-to-a-dataframe",
    "title": "Descargando im√°genes satelitales desde Sentinel Hub con python",
    "section": "Explore list of products to a dataframe",
    "text": "Explore list of products to a dataframe\nExplore and understand features\n\n\nCode\nimport pandas as pd # version: 1.4.2\n\nproducts_gdf = api.to_geodataframe(products)\nproducts_gdf = products_gdf.sort_values(['beginposition'], ascending=[True])\nprint(products_gdf.keys())\nprint(len(products_gdf.keys()))\nproducts_gdf.head(3)"
  },
  {
    "objectID": "posts/geospatial_data/sentinel copy.html#the-spatial-dimension",
    "href": "posts/geospatial_data/sentinel copy.html#the-spatial-dimension",
    "title": "Descargando im√°genes satelitales desde Sentinel Hub con python",
    "section": "The spatial dimension",
    "text": "The spatial dimension\n\n\nCode\nimport folium\nimport geopandas as gpd\n\nx, y = admin_polygon.centroid.xy\nm = folium.Map(location=[y[0], x[0]], zoom_start=8, tiles='CartoDB Dark_Matter')\n\n# visualize a set of random tiles\npolygon_style = { 'fillColor': '#39FF14', 'color': 'black',  'weight': 3, 'opacity': 0}\ngeojson_data = products_gdf[['geometry']].sample(10).to_json()\nfolium.GeoJson(\n    geojson_data,\n    style_function=lambda feature: polygon_style\n).add_to(m)\n\n# add the admin boundaries on top\nadmin_style = {'fillColor': '#00FFFF',  'color': 'black','weight': 3, 'opacity': 100.0  }\nadmin_geojson_data = admin[['geometry']].to_json()\nfolium.GeoJson(\n    admin_geojson_data,\n    style_function=lambda feature: admin_style\n).add_to(m)\n\n# show the map\nm\n\n\nCompute tiles that do not overlap\n\n\nCode\ndef compute_overlapping_area(tile, admin):\n    return tile.intersection(admin_polygon).area / admin_polygon.area\n\nproducts_gdf['overlapping_area_fraction'] = products_gdf.geometry.apply(lambda x: compute_overlapping_area(x, admin_polygon))\nproducts_gdf_f = products_gdf[products_gdf.overlapping_area_fraction==1]\nprint(len(products_gdf))\nprint(len(products_gdf_f))\nproducts_gdf_f.head(3)\n\n\n\n\nCode\nimport folium\nimport geopandas as gpd\n\nx, y = admin_polygon.centroid.xy\nm = folium.Map(location=[y[0], x[0]], zoom_start=8, tiles='CartoDB Dark_Matter')\n\n# visualize a set of random tiles\npolygon_style = { 'fillColor': '#39FF14', 'color': 'black',  'weight': 3, 'opacity': 0}\ngeojson_data = products_gdf_f[['geometry']].sample(10).to_json()\nfolium.GeoJson(\n    geojson_data,\n    style_function=lambda feature: polygon_style\n).add_to(m)\n\n# add the admin boundaries on top\nadmin_style = {'fillColor': '#00FFFF',  'color': 'black','weight': 3, 'opacity': 100.0  }\nadmin_geojson_data = admin[['geometry']].to_json()\nfolium.GeoJson(\n    admin_geojson_data,\n    style_function=lambda feature: admin_style\n).add_to(m)\n\n# show the map\nm"
  },
  {
    "objectID": "posts/geospatial_data/sentinel copy.html#the-temporal-dimension",
    "href": "posts/geospatial_data/sentinel copy.html#the-temporal-dimension",
    "title": "Descargando im√°genes satelitales desde Sentinel Hub con python",
    "section": "The temporal dimension",
    "text": "The temporal dimension\n\n\nCode\n# Assuming 'beginposition' is a Timestamp column in your GeoDataFrame\n# You can convert it to a DateTime index\nproducts_gdf_f_cntr = products_gdf_f.copy()\nproducts_gdf_f_cntr['beginposition'] = pd.to_datetime(products_gdf_f_cntr['beginposition'])\nproducts_gdf_f_cntr.set_index('beginposition', inplace=True)\n\n# Resample the data to count rows per day, week, and month\ndaily_counts = products_gdf_f_cntr.resample('D').count()\nweekly_counts = products_gdf_f_cntr.resample('W').count()\nmonthly_counts = products_gdf_f_cntr.resample('M').count()\n\nfig, ax = plt.subplots(1, 3, figsize=(15, 5))\nfor idx, (count_name, count_val) in enumerate([('Daily Counts', daily_counts), ('Weekly Counts', weekly_counts), ('Monthly Counts', monthly_counts), ]): \n\n    ax[idx].plot(count_val.index[0:250], count_val['geometry'].to_list()[0:250])\n    ax[idx].set_xlabel('Date')\n    ax[idx].set_ylabel('Count')\n    ax[idx].set_title(count_name)\n\n\nplt.tight_layout()\nplt.suptitle('Number of satellite images taken in various time-frames', fontsize = 20, y = 1.15)\nplt.show()"
  },
  {
    "objectID": "posts/geospatial_data/sentinel copy.html#the-temporal-evolution-of-land-cover-variables",
    "href": "posts/geospatial_data/sentinel copy.html#the-temporal-evolution-of-land-cover-variables",
    "title": "Descargando im√°genes satelitales desde Sentinel Hub con python",
    "section": "The temporal evolution of land cover variables",
    "text": "The temporal evolution of land cover variables\n\n\nCode\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Assuming 'beginposition' is a Timestamp column in your GeoDataFrame\n# You can convert it to a DateTime index\nproducts_gdf_f_cntr = products_gdf_f.copy()\nproducts_gdf_f_cntr['beginposition'] = pd.to_datetime(products_gdf_f_cntr['beginposition'])\nproducts_gdf_f_cntr.set_index('beginposition', inplace=True)\n\n# Resample the data to calculate weekly averages\nweekly_averages = products_gdf_f_cntr[['vegetationpercentage', 'waterpercentage', 'snowicepercentage', 'cloudcoverpercentage']].resample('W').mean()\n\n# Create a multi-plot figure with four subplots\nfig, (ax1, ax2, ax3, ax4) = plt.subplots(4, 1, figsize=(10, 15))\n\n# Plot 'vegetationpercentage' with a green line\nax1.plot(weekly_averages.index, weekly_averages['vegetationpercentage'], color='green', label='Weekly Average Vegetation Percentage')\nax1.set_xlabel('Date')\nax1.set_ylabel('Percentage')\nax1.set_title('Weekly Average Vegetation Percentage')\nax1.legend()\n\n# Plot 'waterpercentage' with a blue line\nax2.plot(weekly_averages.index, weekly_averages['waterpercentage'], color='blue', label='Weekly Average Water Percentage')\nax2.set_xlabel('Date')\nax2.set_ylabel('Percentage')\nax2.set_title('Weekly Average Water Percentage')\nax2.legend()\n\n# Plot 'snowicepercentage' with a cyan line\nax3.plot(weekly_averages.index, weekly_averages['snowicepercentage'], color='cyan', label='Weekly Average Snow/Ice Percentage')\nax3.set_xlabel('Date')\nax3.set_ylabel('Percentage')\nax3.set_title('Weekly Average Snow/Ice Percentage')\nax3.legend()\n\n# Plot 'cloudcoverpercentage' with a gray line\nax4.plot(weekly_averages.index, weekly_averages['cloudcoverpercentage'], color='gray', label='Weekly Average Cloud Cover Percentage')\nax4.set_xlabel('Date')\nax4.set_ylabel('Percentage')\nax4.set_title('Weekly Average Cloud Cover Percentage')\nax4.legend()\n\nplt.tight_layout()\nplt.show()\n\n\nTry different resolutions, eg. monthly\nLook at correlations of these time series\n\n\nCode\nproducts_gdf_f_cntr[['vegetationpercentage', 'waterpercentage', 'snowicepercentage', 'cloudcoverpercentage']].corr()"
  },
  {
    "objectID": "posts/geospatial_data/sentinel copy.html#load-sentinel-2-and-3-images",
    "href": "posts/geospatial_data/sentinel copy.html#load-sentinel-2-and-3-images",
    "title": "Descargando im√°genes satelitales desde Sentinel Hub con python",
    "section": "Load Sentinel 2 and 3 images",
    "text": "Load Sentinel 2 and 3 images\n\n\nCode\n# query tile product ids\nproducts_sent = api.query(admin_polygon, date=('20230806', '20230813'), platformname='Sentinel-2', cloudcoverpercentage=(0, 1))\nproducts_sent = api.to_geodataframe(products_sent)\n\nf, ax = plt.subplots(1,1,figsize=(6,4))\nadmin.plot(ax=ax, color = 'none', edgecolor = 'k')\nax.set_title('Sentinel-2, number of tiles = ' + str(len(products_sent)))\nproducts_sent.plot(ax=ax, alpha = 0.3)\n\n\n# filter out the tiles not fully overlapping with Budapest\nproducts_sent['overlapping_area_fraction'] = products_sent.geometry.apply(lambda x: compute_overlapping_area(x, admin_polygon))\nproducts_sent = products_sent[products_sent.overlapping_area_fraction==1]\n\nf, ax = plt.subplots(1,1,figsize=(6,4))\nadmin.plot(ax=ax, color = 'none', edgecolor = 'k')\nax.set_title('Sentinel-2, number of tiles = ' + str(len(products_sent)))\nproducts_sent.plot(ax=ax, alpha = 0.3)\n\n\nlen(products_sent)\n\n\n\n\nCode\n# download the first tiles as sat images\nproduct_ids = products_sent.index.to_list()\n\nfor prod in product_ids:\n    api.download(prod)"
  },
  {
    "objectID": "posts/geospatial_data/sentinel copy.html#open-and-visualize-images",
    "href": "posts/geospatial_data/sentinel copy.html#open-and-visualize-images",
    "title": "Descargando im√°genes satelitales desde Sentinel Hub con python",
    "section": "Open and visualize images",
    "text": "Open and visualize images\n\nSentinel wiki: https://sentinels.copernicus.eu/web/sentinel/user-guides\nSentinel bands: https://gisgeography.com/sentinel-2-bands-combinations/\n\n\n\nCode\n# after unzipping the downloaded folder:\nimport os\nimage_path = 'S2B_MSIL1C_20230810T094549_N0509_R079_T34TCT_20230810T124346.SAFE/GRANULE/L1C_T34TCT_A033567_20230810T095651/IMG_DATA'\nsorted(os.listdir(image_path))\n\n\nCheck a tile using rasterio\n\n\nCode\nimport rasterio\nfrom rasterio.plot import show\n\nimage_file = 'T34TCT_20230810T094549_B04.jp2'\n \nwith rasterio.open(image_path + '/' + image_file) as src:\n    \n    image = src.read(1)  # Change the band index as needed\n    plt.figure(figsize=(10, 10))\n    plt.imshow(image, cmap='Reds')  # You can change the colormap\n    plt.title(image_file)\n    plt.colorbar()\n    plt.show()\n\n\n\n\nCode\nfrom rasterio import mask\n\nf, ax = plt.subplots(1,3,figsize=(15,5))\n\nfor idx, (band_name, band_num, color_map) in enumerate([('Blue', 'B02', 'Blues'), ('Green', 'B03', 'Greens'), ('Red', 'B04', 'Reds')]):\n   \n    raster_path = image_path + '/T34TCT_20230810T094549_' + band_num + '.jp2'\n\n    with rasterio.open(raster_path) as src:\n        polygons = admin.copy().to_crs(src.crs)\n        geom = polygons.geometry.iloc[0]\n        masked_image, _ = mask.mask(src, [geom], crop=True)\n\n    ax[idx].imshow(masked_image[0], cmap=color_map)\n    ax[idx].set_title('Budapest Sentinel 2 - ' + band_name + ' band')\n\n\n\n\nCode\n# Get the band locations\nband_blue = '/T34TCT_20230810T094549_B02.jp2'\nband_green = '/T34TCT_20230810T094549_B03.jp2'\nband_red = '/T34TCT_20230810T094549_B04.jp2'\n\n# Read in the bands and create the full RGB tile\nb2   = rasterio.open(image_path + '/' + band_blue)\nb3   = rasterio.open(image_path + '/' + band_green)\nb4   = rasterio.open(image_path + '/' + band_red)\n\n# export the full tile as a tif file\nmeta = b4.meta\nmeta.update({\"count\": 3})\nprefire_rgb_path = 'budapest_rgb.tif'\nwith rasterio.open(prefire_rgb_path, 'w', **meta) as dest:\n    dest.write(b2.read(1),1)\n    dest.write(b3.read(1),2)\n    dest.write(b4.read(1),3)\n\n# crop and save it to the admin boundaries of budapest\nwith rasterio.open('budapest_rgb.tif') as src:\n    polygons = admin.copy().to_crs(src.crs)\n    geom = polygons.geometry.iloc[0]\n    out_image, out_transform  = mask.mask(src, [geom], crop=True)\n    out_meta = src.meta.copy()\n    out_meta.update({\"driver\": \"GTiff\",\n                     \"height\": out_image.shape[1],\n                     \"width\" : out_image.shape[2],\n                     \"transform\": out_transform})\n\nwith rasterio.open('budapest_rgb_cropped.tif', \"w\", **out_meta) as dest:\n    dest.write(out_image)\n    \n    \n# read and show the cropped version\nimport numpy as np\nfrom skimage import exposure\n\nimg = rasterio.open('budapest_rgb_cropped.tif')\nimage = np.array([img.read(3), img.read(2), img.read(1)])\nimage = image.transpose(1,2,0)\n\n# do the histogram equalization\np2, p98 = np.percentile(image, (2,98))\nimage = exposure.rescale_intensity(image, in_range=(p2, p98)) / 100000\n\nf, ax = plt.subplots(1,1,figsize=(15,15))\nrasterio.plot.show(image.transpose(2,0,1), transform=img.transform, ax = ax)\nax.axis('off')\nplt.savefig('budapest_rgb_cropped_2.png', dpi = 100, bbox_inches = 'tight')"
  },
  {
    "objectID": "posts/geospatial_data/sentinelhub.html",
    "href": "posts/geospatial_data/sentinelhub.html",
    "title": "Explorando la API de Sentinel Hub para im√°genes satelitales",
    "section": "",
    "text": "Siempre me perd√≠ en el proceso de encontrar im√°genes satelitales entre tanta API, fuentes de informaci√≥n y todo. Aqu√≠ un art√≠culo para cerrar esa brecha.\nHace poco tiempo descubr√≠ Sentinel Hub (https://www.sentinel-hub.com/), que seg√∫n sus propias palabras se definen como:\nPerfeeecto. Entonces, aparte de ofrecernos una plataforma para el procesamiento de im√°genes, nos ofrece f√°cil acceso a una extensa colecci√≥n de im√°genes. Tremendo. Pero esto no puede ser gratis‚Ä¶ o s√≠?\nPara el plan gratuito, tenemos 5,000 processing units (PUs) o requests a la API al mes, o 300 por minuto. Qu√© es un PU? Una im√°gen de 512x512, 16 bits y 3 bandas cuesta un PU, aproximadamente. Suena bien, vamos!\nPrimero, debemos hacer dos cosas: i) crear una cuenta en Sentinel Hub y ii) instalar la librer√≠a para acceder a la API. Para lo primero, crea un usuario en la p√°gina, y luego clickea en Account Settings. Despu√©s, tienes que crear un cliente para poder consultar la API (OAuth client), donde obtendr√°s un usuario y clave. En mi caso, ya cre√© uno como se muestra en la im√°gen abajo.\nAhora la parte ii): necesitamos instalar el paquete de python de sentinel hub:\npip install sentinelhub\nY estamos listos para empezar a descargar esas im√°genes como si no hubiera un ma√±ana.\nfrom sentinelhub import SHConfig\n\nclient_secret = \"a_secret\"\nclient_id = \"an_id\"\nconfig = SHConfig(sh_client_id = client_id, sh_client_secret = client_secret)"
  },
  {
    "objectID": "posts/geospatial_data/sentinelhub.html#paso-1-instalaci√≥n-y-autenticaci√≥n",
    "href": "posts/geospatial_data/sentinelhub.html#paso-1-instalaci√≥n-y-autenticaci√≥n",
    "title": "Explorando la API de Sentinel Hub para im√°genes satelitales",
    "section": "Paso #1: instalaci√≥n y autenticaci√≥n",
    "text": "Paso #1: instalaci√≥n y autenticaci√≥n\nPrimero, debemos hacer dos cosas: i) crear una cuenta en Sentinel Hub y ii) instalar la librer√≠a para acceder a la API. Para lo primero, crea un usuario en la p√°gina, y luego clickea en Account Settings. Despu√©s, tienes que crear un cliente para poder consultar la API (OAuth client), donde obtendr√°s un usuario y clave. En mi caso, ya cre√© uno como se muestra en la im√°gen abajo.\n\n\n\nOAuth client de la API.\n\n\nAhora la parte ii): necesitamos instalar el paquete de python de sentinel hub:\n\npip install sentinelhub\n\nY estamos listos para empezar a descargar esas im√°genes como si no hubiera un ma√±ana.\n\nfrom sentinelhub import SHConfig\n\nclient_secret = \"a_secret\"\nclient_id = \"an_id\"\nconfig = SHConfig(sh_client_id = client_id, sh_client_secret = client_secret)"
  },
  {
    "objectID": "posts/geospatial_data/sentinelhub.html#pick-a-spot-and-find-its-boundary-data",
    "href": "posts/geospatial_data/sentinelhub.html#pick-a-spot-and-find-its-boundary-data",
    "title": "Explorando la API de Sentinel Hub para im√°genes satelitales",
    "section": "Pick a spot and find its boundary data",
    "text": "Pick a spot and find its boundary data\nWe will first load from OSMNx library the political boundaries of a target spot.\n\nimport osmnx as ox \nimport matplotlib.pyplot as plt\n\nprint(\"osmnx version: \", ox.__version__)\n\nosmnx version:  1.9.2\n\n\n\ncity = 'Valdivia'\nadmin = ox.geocode_to_gdf(city)\nadmin.plot();\n\n\n\n\n\n\n\n\nLet¬¥s build a convex hull from the above polygon, so we can get a cleaner search area.\n\nadmin_polygon = admin.convex_hull.geometry.to_list()[0]\nadmin_polygon"
  },
  {
    "objectID": "posts/geospatial_data/sentinelhub.html#find-satellite-data",
    "href": "posts/geospatial_data/sentinelhub.html#find-satellite-data",
    "title": "Explorando la API de Sentinel Hub para im√°genes satelitales",
    "section": "Find satellite data",
    "text": "Find satellite data\nWe need satellite data to support any analysis on data. Here is a list for the top satellite maps in 2024: - Satellite maps sources\nSentinel images is a good option! There are six Sentinel missions, where three can be accessed through its API. Let¬¥s check the description for each set of images:\n\nSentinel-1\n\nApplications: Sentinel-1 is used for monitoring changes in land cover, detecting deforestation, mapping floods, monitoring sea ice, and supporting maritime surveillance.\nInformation: Sentinel-1 is a radar imaging satellite that provides all-weather, day-and-night radar imagery.\nResolution: Sentinel-1 offers various resolution modes, including: Interferometric Wide swath mode (IW): 5 m x 20 m (VV and VH polarizations) Extra Wide swath mode (EW): 20 m x 40 m (HH polarization)\nStripmap mode (SM): 5 m x 5 m (VV and VH polarizations)\n\n\n\nSentinel-2\n\nInformation: Sentinel-2 is a multispectral optical imaging satellite, providing high-resolution imagery in 13 spectral bands.\nResolution: Sentinel-2 offers the following spatial resolutions:\n\n10 meters for the visible and near-infrared bands\n20 meters for the red edge and shortwave infrared bands\n60 meters for the atmospheric and water vapor bands\n\nApplications: Sentinel-2 is widely used for monitoring agriculture, forestry, land cover changes, urban planning, and environmental monitoring.\n\n\n\nSentinel-3:\n\nInformation: Sentinel-3 is a multi-instrument satellite mission designed for oceanographic and land monitoring applications.\nResolution: Sentinel-3 provides different resolution characteristics depending on the instrument:\n\nSea and Land Surface Temperature Radiometer (SLSTR): Spatial resolution varies from 500 m to 1 km\nOcean and Land Colour Instrument (OLCI): Spatial resolution ranges from 300 m to 1 km\nSynthetic Aperture Radar Altimeter (SRAL): Spatial resolution is around 300 m over the ocean\n\nApplications: Sentinel-3 is primarily used for monitoring ocean ecosystems, sea surface temperature, ocean color, sea level changes, land surface temperature, and vegetation health.\n\nLet¬¥s use Sentinel-2 images! We can use the sentinelsat library and can download images after authentication.\n\nfrom sentinelhub import SHConfig\n\n#client_secret = 'GEZixbNoqGcFYiFMNSLz74HrzN03rfvi'\n#client_id = '10e7a03e-5783-413f-a5ba-3e1a452ce742'\n\nclient_secret = \"2q0hrUeD6QSELMvyWhxADiBHLKianGvP\"\nclient_id = \"ef03eb3d-e59f-4137-aecf-fae1eac611c7\"\n\nconfig = SHConfig(sh_client_id = client_id, sh_client_secret = client_secret)\n\n\nimport sentinelsat\nprint(\"sentinelsat version: \", sentinelsat.__version__)\n\nfrom sentinelsat import SentinelAPI, read_geojson, geojson_to_wkt\n\nsentinelsat version:  1.2.1\n\n\n\nuser = \"8410ee66-5680-4948-94ee-1051e60a7cdd\"\npassword = \"Av_.!H3rJGw5MCc\"\napi = SentinelAPI(user, password, 'https://apihub.copernicus.eu/apihub') \n\nYou can query the API by specifying the polygon area, range of dates, which sentinel data and cloud coverage properties.\n\n# location (based on a polygon)\n# the time frame\n# the space probe\n# and the level of cloud-coverage accepted \n\nproducts = api.query(\n    admin_polygon,\n    #date=('20150623', '20231006'),\n    date=('20230623', '20230723'),\n    platformname='Sentinel-2',\n    cloudcoverpercentage=(0, 100)\n)\n\nlen(products)\n\nConnectTimeout: HTTPSConnectionPool(host='apihub.copernicus.eu', port=443): Max retries exceeded with url: /apihub/search?format=json&rows=100&start=0&q=beginPosition%3A%5B%222023-06-23T00%3A00%3A00Z%22+TO+%222023-07-23T00%3A00%3A00Z%22%5D+cloudcoverpercentage%3A%5B%220%22+TO+%22100%22%5D+platformname%3A%22Sentinel-2%22+footprint%3A%22Intersects%28POLYGON+%28%28-73.0818064+-40.0320178%2C+-73.0825359+-40.0319356%2C+-73.10659+-40.023901%2C+-73.1442278+-40.0089817%2C+-73.1454724+-40.0084722%2C+-73.4075993+-39.8818511%2C+-73.410775+-39.8790189%2C+-73.4139412+-39.871497%2C+-73.4114492+-39.7158156%2C+-73.404981+-39.6940462%2C+-73.4049395+-39.6939276%2C+-73.4021795+-39.6909947%2C+-73.4021044+-39.6909163%2C+-73.3607501+-39.656072%2C+-73.3600581+-39.655597%2C+-73.3304465+-39.6404608%2C+-73.3230436+-39.6374307%2C+-73.3226037+-39.6373398%2C+-73.3210373+-39.6370796%2C+-73.2834452+-39.6432413%2C+-73.2429331+-39.6499494%2C+-73.0229319+-39.6924461%2C+-72.9732102+-39.7974574%2C+-72.9230207+-39.9296844%2C+-72.9220122+-39.9348509%2C+-72.9208535+-39.9412673%2C+-73.0809706+-40.0317574%2C+-73.0818064+-40.0320178%29%29%29%22 (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPSConnection object at 0x15b635e80&gt;, 'Connection to apihub.copernicus.eu timed out. (connect timeout=None)'))"
  },
  {
    "objectID": "posts/geospatial_data/sentinelhub.html#explore-list-of-products-to-a-dataframe",
    "href": "posts/geospatial_data/sentinelhub.html#explore-list-of-products-to-a-dataframe",
    "title": "Explorando la API de Sentinel Hub para im√°genes satelitales",
    "section": "Explore list of products to a dataframe",
    "text": "Explore list of products to a dataframe\nExplore and understand features\n\nimport pandas as pd # version: 1.4.2\n\nproducts_gdf = api.to_geodataframe(products)\nproducts_gdf = products_gdf.sort_values(['beginposition'], ascending=[True])\nprint(products_gdf.keys())\nprint(len(products_gdf.keys()))\nproducts_gdf.head(3)"
  },
  {
    "objectID": "posts/geospatial_data/sentinelhub.html#the-spatial-dimension",
    "href": "posts/geospatial_data/sentinelhub.html#the-spatial-dimension",
    "title": "Explorando la API de Sentinel Hub para im√°genes satelitales",
    "section": "The spatial dimension",
    "text": "The spatial dimension\n\nimport folium\nimport geopandas as gpd\n\nx, y = admin_polygon.centroid.xy\nm = folium.Map(location=[y[0], x[0]], zoom_start=8, tiles='CartoDB Dark_Matter')\n\n# visualize a set of random tiles\npolygon_style = { 'fillColor': '#39FF14', 'color': 'black',  'weight': 3, 'opacity': 0}\ngeojson_data = products_gdf[['geometry']].sample(10).to_json()\nfolium.GeoJson(\n    geojson_data,\n    style_function=lambda feature: polygon_style\n).add_to(m)\n\n# add the admin boundaries on top\nadmin_style = {'fillColor': '#00FFFF',  'color': 'black','weight': 3, 'opacity': 100.0  }\nadmin_geojson_data = admin[['geometry']].to_json()\nfolium.GeoJson(\n    admin_geojson_data,\n    style_function=lambda feature: admin_style\n).add_to(m)\n\n# show the map\nm\n\nCompute tiles that do not overlap\n\ndef compute_overlapping_area(tile, admin):\n    return tile.intersection(admin_polygon).area / admin_polygon.area\n\nproducts_gdf['overlapping_area_fraction'] = products_gdf.geometry.apply(lambda x: compute_overlapping_area(x, admin_polygon))\nproducts_gdf_f = products_gdf[products_gdf.overlapping_area_fraction==1]\nprint(len(products_gdf))\nprint(len(products_gdf_f))\nproducts_gdf_f.head(3)\n\n\nimport folium\nimport geopandas as gpd\n\nx, y = admin_polygon.centroid.xy\nm = folium.Map(location=[y[0], x[0]], zoom_start=8, tiles='CartoDB Dark_Matter')\n\n# visualize a set of random tiles\npolygon_style = { 'fillColor': '#39FF14', 'color': 'black',  'weight': 3, 'opacity': 0}\ngeojson_data = products_gdf_f[['geometry']].sample(10).to_json()\nfolium.GeoJson(\n    geojson_data,\n    style_function=lambda feature: polygon_style\n).add_to(m)\n\n# add the admin boundaries on top\nadmin_style = {'fillColor': '#00FFFF',  'color': 'black','weight': 3, 'opacity': 100.0  }\nadmin_geojson_data = admin[['geometry']].to_json()\nfolium.GeoJson(\n    admin_geojson_data,\n    style_function=lambda feature: admin_style\n).add_to(m)\n\n# show the map\nm"
  },
  {
    "objectID": "posts/geospatial_data/sentinelhub.html#the-temporal-dimension",
    "href": "posts/geospatial_data/sentinelhub.html#the-temporal-dimension",
    "title": "Explorando la API de Sentinel Hub para im√°genes satelitales",
    "section": "The temporal dimension",
    "text": "The temporal dimension\n\n# Assuming 'beginposition' is a Timestamp column in your GeoDataFrame\n# You can convert it to a DateTime index\nproducts_gdf_f_cntr = products_gdf_f.copy()\nproducts_gdf_f_cntr['beginposition'] = pd.to_datetime(products_gdf_f_cntr['beginposition'])\nproducts_gdf_f_cntr.set_index('beginposition', inplace=True)\n\n# Resample the data to count rows per day, week, and month\ndaily_counts = products_gdf_f_cntr.resample('D').count()\nweekly_counts = products_gdf_f_cntr.resample('W').count()\nmonthly_counts = products_gdf_f_cntr.resample('M').count()\n\nfig, ax = plt.subplots(1, 3, figsize=(15, 5))\nfor idx, (count_name, count_val) in enumerate([('Daily Counts', daily_counts), ('Weekly Counts', weekly_counts), ('Monthly Counts', monthly_counts), ]): \n\n    ax[idx].plot(count_val.index[0:250], count_val['geometry'].to_list()[0:250])\n    ax[idx].set_xlabel('Date')\n    ax[idx].set_ylabel('Count')\n    ax[idx].set_title(count_name)\n\n\nplt.tight_layout()\nplt.suptitle('Number of satellite images taken in various time-frames', fontsize = 20, y = 1.15)\nplt.show()"
  },
  {
    "objectID": "posts/geospatial_data/sentinelhub.html#the-temporal-evolution-of-land-cover-variables",
    "href": "posts/geospatial_data/sentinelhub.html#the-temporal-evolution-of-land-cover-variables",
    "title": "Explorando la API de Sentinel Hub para im√°genes satelitales",
    "section": "The temporal evolution of land cover variables",
    "text": "The temporal evolution of land cover variables\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Assuming 'beginposition' is a Timestamp column in your GeoDataFrame\n# You can convert it to a DateTime index\nproducts_gdf_f_cntr = products_gdf_f.copy()\nproducts_gdf_f_cntr['beginposition'] = pd.to_datetime(products_gdf_f_cntr['beginposition'])\nproducts_gdf_f_cntr.set_index('beginposition', inplace=True)\n\n# Resample the data to calculate weekly averages\nweekly_averages = products_gdf_f_cntr[['vegetationpercentage', 'waterpercentage', 'snowicepercentage', 'cloudcoverpercentage']].resample('W').mean()\n\n# Create a multi-plot figure with four subplots\nfig, (ax1, ax2, ax3, ax4) = plt.subplots(4, 1, figsize=(10, 15))\n\n# Plot 'vegetationpercentage' with a green line\nax1.plot(weekly_averages.index, weekly_averages['vegetationpercentage'], color='green', label='Weekly Average Vegetation Percentage')\nax1.set_xlabel('Date')\nax1.set_ylabel('Percentage')\nax1.set_title('Weekly Average Vegetation Percentage')\nax1.legend()\n\n# Plot 'waterpercentage' with a blue line\nax2.plot(weekly_averages.index, weekly_averages['waterpercentage'], color='blue', label='Weekly Average Water Percentage')\nax2.set_xlabel('Date')\nax2.set_ylabel('Percentage')\nax2.set_title('Weekly Average Water Percentage')\nax2.legend()\n\n# Plot 'snowicepercentage' with a cyan line\nax3.plot(weekly_averages.index, weekly_averages['snowicepercentage'], color='cyan', label='Weekly Average Snow/Ice Percentage')\nax3.set_xlabel('Date')\nax3.set_ylabel('Percentage')\nax3.set_title('Weekly Average Snow/Ice Percentage')\nax3.legend()\n\n# Plot 'cloudcoverpercentage' with a gray line\nax4.plot(weekly_averages.index, weekly_averages['cloudcoverpercentage'], color='gray', label='Weekly Average Cloud Cover Percentage')\nax4.set_xlabel('Date')\nax4.set_ylabel('Percentage')\nax4.set_title('Weekly Average Cloud Cover Percentage')\nax4.legend()\n\nplt.tight_layout()\nplt.show()\n\nTry different resolutions, eg. monthly\nLook at correlations of these time series\n\nproducts_gdf_f_cntr[['vegetationpercentage', 'waterpercentage', 'snowicepercentage', 'cloudcoverpercentage']].corr()"
  },
  {
    "objectID": "posts/geospatial_data/sentinelhub.html#load-sentinel-2-and-3-images",
    "href": "posts/geospatial_data/sentinelhub.html#load-sentinel-2-and-3-images",
    "title": "Explorando la API de Sentinel Hub para im√°genes satelitales",
    "section": "Load Sentinel 2 and 3 images",
    "text": "Load Sentinel 2 and 3 images\n\n# query tile product ids\nproducts_sent = api.query(admin_polygon, date=('20230806', '20230813'), platformname='Sentinel-2', cloudcoverpercentage=(0, 1))\nproducts_sent = api.to_geodataframe(products_sent)\n\nf, ax = plt.subplots(1,1,figsize=(6,4))\nadmin.plot(ax=ax, color = 'none', edgecolor = 'k')\nax.set_title('Sentinel-2, number of tiles = ' + str(len(products_sent)))\nproducts_sent.plot(ax=ax, alpha = 0.3)\n\n\n# filter out the tiles not fully overlapping with Budapest\nproducts_sent['overlapping_area_fraction'] = products_sent.geometry.apply(lambda x: compute_overlapping_area(x, admin_polygon))\nproducts_sent = products_sent[products_sent.overlapping_area_fraction==1]\n\nf, ax = plt.subplots(1,1,figsize=(6,4))\nadmin.plot(ax=ax, color = 'none', edgecolor = 'k')\nax.set_title('Sentinel-2, number of tiles = ' + str(len(products_sent)))\nproducts_sent.plot(ax=ax, alpha = 0.3)\n\n\nlen(products_sent)\n\n\n# download the first tiles as sat images\nproduct_ids = products_sent.index.to_list()\n\nfor prod in product_ids:\n    api.download(prod)"
  },
  {
    "objectID": "posts/geospatial_data/sentinelhub.html#open-and-visualize-images",
    "href": "posts/geospatial_data/sentinelhub.html#open-and-visualize-images",
    "title": "Explorando la API de Sentinel Hub para im√°genes satelitales",
    "section": "Open and visualize images",
    "text": "Open and visualize images\n\nSentinel wiki: https://sentinels.copernicus.eu/web/sentinel/user-guides\nSentinel bands: https://gisgeography.com/sentinel-2-bands-combinations/\n\n\n# after unzipping the downloaded folder:\nimport os\nimage_path = 'S2B_MSIL1C_20230810T094549_N0509_R079_T34TCT_20230810T124346.SAFE/GRANULE/L1C_T34TCT_A033567_20230810T095651/IMG_DATA'\nsorted(os.listdir(image_path))\n\nCheck a tile using rasterio\n\nimport rasterio\nfrom rasterio.plot import show\n\nimage_file = 'T34TCT_20230810T094549_B04.jp2'\n \nwith rasterio.open(image_path + '/' + image_file) as src:\n    \n    image = src.read(1)  # Change the band index as needed\n    plt.figure(figsize=(10, 10))\n    plt.imshow(image, cmap='Reds')  # You can change the colormap\n    plt.title(image_file)\n    plt.colorbar()\n    plt.show()\n\n\nfrom rasterio import mask\n\nf, ax = plt.subplots(1,3,figsize=(15,5))\n\nfor idx, (band_name, band_num, color_map) in enumerate([('Blue', 'B02', 'Blues'), ('Green', 'B03', 'Greens'), ('Red', 'B04', 'Reds')]):\n   \n    raster_path = image_path + '/T34TCT_20230810T094549_' + band_num + '.jp2'\n\n    with rasterio.open(raster_path) as src:\n        polygons = admin.copy().to_crs(src.crs)\n        geom = polygons.geometry.iloc[0]\n        masked_image, _ = mask.mask(src, [geom], crop=True)\n\n    ax[idx].imshow(masked_image[0], cmap=color_map)\n    ax[idx].set_title('Budapest Sentinel 2 - ' + band_name + ' band')\n\n\n# Get the band locations\nband_blue = '/T34TCT_20230810T094549_B02.jp2'\nband_green = '/T34TCT_20230810T094549_B03.jp2'\nband_red = '/T34TCT_20230810T094549_B04.jp2'\n\n# Read in the bands and create the full RGB tile\nb2   = rasterio.open(image_path + '/' + band_blue)\nb3   = rasterio.open(image_path + '/' + band_green)\nb4   = rasterio.open(image_path + '/' + band_red)\n\n# export the full tile as a tif file\nmeta = b4.meta\nmeta.update({\"count\": 3})\nprefire_rgb_path = 'budapest_rgb.tif'\nwith rasterio.open(prefire_rgb_path, 'w', **meta) as dest:\n    dest.write(b2.read(1),1)\n    dest.write(b3.read(1),2)\n    dest.write(b4.read(1),3)\n\n# crop and save it to the admin boundaries of budapest\nwith rasterio.open('budapest_rgb.tif') as src:\n    polygons = admin.copy().to_crs(src.crs)\n    geom = polygons.geometry.iloc[0]\n    out_image, out_transform  = mask.mask(src, [geom], crop=True)\n    out_meta = src.meta.copy()\n    out_meta.update({\"driver\": \"GTiff\",\n                     \"height\": out_image.shape[1],\n                     \"width\" : out_image.shape[2],\n                     \"transform\": out_transform})\n\nwith rasterio.open('budapest_rgb_cropped.tif', \"w\", **out_meta) as dest:\n    dest.write(out_image)\n    \n    \n# read and show the cropped version\nimport numpy as np\nfrom skimage import exposure\n\nimg = rasterio.open('budapest_rgb_cropped.tif')\nimage = np.array([img.read(3), img.read(2), img.read(1)])\nimage = image.transpose(1,2,0)\n\n# do the histogram equalization\np2, p98 = np.percentile(image, (2,98))\nimage = exposure.rescale_intensity(image, in_range=(p2, p98)) / 100000\n\nf, ax = plt.subplots(1,1,figsize=(15,15))\nrasterio.plot.show(image.transpose(2,0,1), transform=img.transform, ax = ax)\nax.axis('off')\nplt.savefig('budapest_rgb_cropped_2.png', dpi = 100, bbox_inches = 'tight')"
  },
  {
    "objectID": "posts/geospatial_data/sentinelhub.html#explorando-la-api",
    "href": "posts/geospatial_data/sentinelhub.html#explorando-la-api",
    "title": "Explorando la API de Sentinel Hub para im√°genes satelitales",
    "section": "Explorando la API",
    "text": "Explorando la API\nLo primero que necesitamos hacer es definir un bounding box. Una forma r√°pida de hacerlo es explorando http://bboxfinder.com/ . El formato de la bbox deber ser una tupla con pares (lat, long) para el punto superior izquierdo y (lat, long) para el punto inferior derecho.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom sentinelhub import (\n    CRS,\n    BBox,\n    DataCollection,\n    #DownloadRequest,\n    MimeType,\n    MosaickingOrder,\n    #SentinelHubDownloadClient,\n    SentinelHubRequest,\n    bbox_to_dimensions,\n)\n\nPodemos calcular, definiendo la resoluci√≥n que necesitamos, el tama√±o de la imagen en pixeles. La API permite dimensiones menores a 2500 pixeles.\n\nbetsiboka_coords_wgs84 = (46.16, -16.15, 46.51, -15.58)\n\nresolution = 60\nbetsiboka_bbox = BBox(bbox=betsiboka_coords_wgs84, crs=CRS.WGS84)\nbetsiboka_size = bbox_to_dimensions(betsiboka_bbox, resolution=resolution)\n\nprint(f\"Image shape at {resolution} m resolution: {betsiboka_size} pixels\")\n\nImage shape at 60 m resolution: (631, 1047) pixels\n\n\nExisten distintas colecciones de im√°genes (misiones satelitales?) donde cada una obtiene im√°genes con distintas propiedades y para diferentes fines. Ac√° podemos explorar una lista de √©stas.\n\nprint(\"Supported DataCollections:\\n\")\nfor collection in DataCollection.get_available_collections():\n    print(collection)\n\nSupported DataCollections:\n\nDataCollection.SENTINEL2_L1C\nDataCollection.SENTINEL2_L2A\nDataCollection.SENTINEL1\nDataCollection.SENTINEL1_IW\nDataCollection.SENTINEL1_IW_ASC\nDataCollection.SENTINEL1_IW_DES\nDataCollection.SENTINEL1_EW\nDataCollection.SENTINEL1_EW_ASC\nDataCollection.SENTINEL1_EW_DES\nDataCollection.SENTINEL1_EW_SH\nDataCollection.SENTINEL1_EW_SH_ASC\nDataCollection.SENTINEL1_EW_SH_DES\nDataCollection.DEM\nDataCollection.DEM_MAPZEN\nDataCollection.DEM_COPERNICUS_30\nDataCollection.DEM_COPERNICUS_90\nDataCollection.MODIS\nDataCollection.LANDSAT_MSS_L1\nDataCollection.LANDSAT_TM_L1\nDataCollection.LANDSAT_TM_L2\nDataCollection.LANDSAT_ETM_L1\nDataCollection.LANDSAT_ETM_L2\nDataCollection.LANDSAT_OT_L1\nDataCollection.LANDSAT_OT_L2\nDataCollection.SENTINEL5P\nDataCollection.SENTINEL3_OLCI\nDataCollection.SENTINEL3_SLSTR\nDataCollection.HARMONIZED_LANDSAT_SENTINEL\n\n\nPor ejemplo, tomemos Sentinel-2 (L1C) y veamos sus propiedades.\n\nDataCollection.SENTINEL2_L1C\n\n&lt;DataCollection.SENTINEL2_L1C: DataCollectionDefinition(\n  api_id: sentinel-2-l1c\n  catalog_id: sentinel-2-l1c\n  wfs_id: DSS1\n  service_url: https://services.sentinel-hub.com\n  collection_type: Sentinel-2\n  sensor_type: MSI\n  processing_level: L1C\n  bands: (Band(name='B01', units=(&lt;Unit.REFLECTANCE: 'REFLECTANCE'&gt;, &lt;Unit.DN: 'DN'&gt;), output_types=(&lt;class 'numpy.float32'&gt;, &lt;class 'numpy.uint16'&gt;)), Band(name='B02', units=(&lt;Unit.REFLECTANCE: 'REFLECTANCE'&gt;, &lt;Unit.DN: 'DN'&gt;), output_types=(&lt;class 'numpy.float32'&gt;, &lt;class 'numpy.uint16'&gt;)), Band(name='B03', units=(&lt;Unit.REFLECTANCE: 'REFLECTANCE'&gt;, &lt;Unit.DN: 'DN'&gt;), output_types=(&lt;class 'numpy.float32'&gt;, &lt;class 'numpy.uint16'&gt;)), Band(name='B04', units=(&lt;Unit.REFLECTANCE: 'REFLECTANCE'&gt;, &lt;Unit.DN: 'DN'&gt;), output_types=(&lt;class 'numpy.float32'&gt;, &lt;class 'numpy.uint16'&gt;)), Band(name='B05', units=(&lt;Unit.REFLECTANCE: 'REFLECTANCE'&gt;, &lt;Unit.DN: 'DN'&gt;), output_types=(&lt;class 'numpy.float32'&gt;, &lt;class 'numpy.uint16'&gt;)), Band(name='B06', units=(&lt;Unit.REFLECTANCE: 'REFLECTANCE'&gt;, &lt;Unit.DN: 'DN'&gt;), output_types=(&lt;class 'numpy.float32'&gt;, &lt;class 'numpy.uint16'&gt;)), Band(name='B07', units=(&lt;Unit.REFLECTANCE: 'REFLECTANCE'&gt;, &lt;Unit.DN: 'DN'&gt;), output_types=(&lt;class 'numpy.float32'&gt;, &lt;class 'numpy.uint16'&gt;)), Band(name='B08', units=(&lt;Unit.REFLECTANCE: 'REFLECTANCE'&gt;, &lt;Unit.DN: 'DN'&gt;), output_types=(&lt;class 'numpy.float32'&gt;, &lt;class 'numpy.uint16'&gt;)), Band(name='B8A', units=(&lt;Unit.REFLECTANCE: 'REFLECTANCE'&gt;, &lt;Unit.DN: 'DN'&gt;), output_types=(&lt;class 'numpy.float32'&gt;, &lt;class 'numpy.uint16'&gt;)), Band(name='B09', units=(&lt;Unit.REFLECTANCE: 'REFLECTANCE'&gt;, &lt;Unit.DN: 'DN'&gt;), output_types=(&lt;class 'numpy.float32'&gt;, &lt;class 'numpy.uint16'&gt;)), Band(name='B10', units=(&lt;Unit.REFLECTANCE: 'REFLECTANCE'&gt;, &lt;Unit.DN: 'DN'&gt;), output_types=(&lt;class 'numpy.float32'&gt;, &lt;class 'numpy.uint16'&gt;)), Band(name='B11', units=(&lt;Unit.REFLECTANCE: 'REFLECTANCE'&gt;, &lt;Unit.DN: 'DN'&gt;), output_types=(&lt;class 'numpy.float32'&gt;, &lt;class 'numpy.uint16'&gt;)), Band(name='B12', units=(&lt;Unit.REFLECTANCE: 'REFLECTANCE'&gt;, &lt;Unit.DN: 'DN'&gt;), output_types=(&lt;class 'numpy.float32'&gt;, &lt;class 'numpy.uint16'&gt;)))\n  metabands: (Band(name='sunAzimuthAngles', units=(&lt;Unit.DEGREES: 'DEGREES'&gt;,), output_types=(&lt;class 'numpy.float32'&gt;,)), Band(name='viewAzimuthMean', units=(&lt;Unit.DEGREES: 'DEGREES'&gt;,), output_types=(&lt;class 'numpy.float32'&gt;,)), Band(name='sunZenithAngles', units=(&lt;Unit.DEGREES: 'DEGREES'&gt;,), output_types=(&lt;class 'numpy.float32'&gt;,)), Band(name='viewZenithMean', units=(&lt;Unit.DEGREES: 'DEGREES'&gt;,), output_types=(&lt;class 'numpy.float32'&gt;,)), Band(name='CLP', units=(&lt;Unit.DN: 'DN'&gt;,), output_types=(&lt;class 'numpy.uint8'&gt;,)), Band(name='CLM', units=(&lt;Unit.DN: 'DN'&gt;,), output_types=(&lt;class 'numpy.uint8'&gt;,)), Band(name='dataMask', units=(&lt;Unit.DN: 'DN'&gt;,), output_types=(&lt;class 'bool'&gt;,)))\n  is_timeless: False\n  has_cloud_coverage: True\n)&gt;\n\n\nVeamos qu√© bandas trae esta colecci√≥n, y en qu√© data type vienen.\n\nDataCollection.SENTINEL2_L1C.bands\n\n(Band(name='B01', units=(&lt;Unit.REFLECTANCE: 'REFLECTANCE'&gt;, &lt;Unit.DN: 'DN'&gt;), output_types=(&lt;class 'numpy.float32'&gt;, &lt;class 'numpy.uint16'&gt;)),\n Band(name='B02', units=(&lt;Unit.REFLECTANCE: 'REFLECTANCE'&gt;, &lt;Unit.DN: 'DN'&gt;), output_types=(&lt;class 'numpy.float32'&gt;, &lt;class 'numpy.uint16'&gt;)),\n Band(name='B03', units=(&lt;Unit.REFLECTANCE: 'REFLECTANCE'&gt;, &lt;Unit.DN: 'DN'&gt;), output_types=(&lt;class 'numpy.float32'&gt;, &lt;class 'numpy.uint16'&gt;)),\n Band(name='B04', units=(&lt;Unit.REFLECTANCE: 'REFLECTANCE'&gt;, &lt;Unit.DN: 'DN'&gt;), output_types=(&lt;class 'numpy.float32'&gt;, &lt;class 'numpy.uint16'&gt;)),\n Band(name='B05', units=(&lt;Unit.REFLECTANCE: 'REFLECTANCE'&gt;, &lt;Unit.DN: 'DN'&gt;), output_types=(&lt;class 'numpy.float32'&gt;, &lt;class 'numpy.uint16'&gt;)),\n Band(name='B06', units=(&lt;Unit.REFLECTANCE: 'REFLECTANCE'&gt;, &lt;Unit.DN: 'DN'&gt;), output_types=(&lt;class 'numpy.float32'&gt;, &lt;class 'numpy.uint16'&gt;)),\n Band(name='B07', units=(&lt;Unit.REFLECTANCE: 'REFLECTANCE'&gt;, &lt;Unit.DN: 'DN'&gt;), output_types=(&lt;class 'numpy.float32'&gt;, &lt;class 'numpy.uint16'&gt;)),\n Band(name='B08', units=(&lt;Unit.REFLECTANCE: 'REFLECTANCE'&gt;, &lt;Unit.DN: 'DN'&gt;), output_types=(&lt;class 'numpy.float32'&gt;, &lt;class 'numpy.uint16'&gt;)),\n Band(name='B8A', units=(&lt;Unit.REFLECTANCE: 'REFLECTANCE'&gt;, &lt;Unit.DN: 'DN'&gt;), output_types=(&lt;class 'numpy.float32'&gt;, &lt;class 'numpy.uint16'&gt;)),\n Band(name='B09', units=(&lt;Unit.REFLECTANCE: 'REFLECTANCE'&gt;, &lt;Unit.DN: 'DN'&gt;), output_types=(&lt;class 'numpy.float32'&gt;, &lt;class 'numpy.uint16'&gt;)),\n Band(name='B10', units=(&lt;Unit.REFLECTANCE: 'REFLECTANCE'&gt;, &lt;Unit.DN: 'DN'&gt;), output_types=(&lt;class 'numpy.float32'&gt;, &lt;class 'numpy.uint16'&gt;)),\n Band(name='B11', units=(&lt;Unit.REFLECTANCE: 'REFLECTANCE'&gt;, &lt;Unit.DN: 'DN'&gt;), output_types=(&lt;class 'numpy.float32'&gt;, &lt;class 'numpy.uint16'&gt;)),\n Band(name='B12', units=(&lt;Unit.REFLECTANCE: 'REFLECTANCE'&gt;, &lt;Unit.DN: 'DN'&gt;), output_types=(&lt;class 'numpy.float32'&gt;, &lt;class 'numpy.uint16'&gt;)))\n\n\nAhora, veamos c√≥mo podemos estructurar una query para hacer la llamada a la API. Para esto, se utiliza un script escrito en Javascript para controlar qu√© valores devolver√° el servicio de Sentinel Hub.\n\nevalscript = \"\"\"\n    //VERSION=3\n    \n    function setup() {\n        return {\n            input: [{bands: [\"B02\", \"B03\", \"B04\"]}],\n            output: {bands: 3}\n        };\n    }\n    function evaluatePixel(sample) {\n        return [sample.B04, sample.B03, sample.B02];\n    }\n\"\"\"\n\nLa funci√≥n setup() se llama una sola vez al principio y es donde definimos el input y output de l√°s im√°genes a procesar. Aqu√≠ especificamos las bandas que necesitaremos. Despu√©s, evaluatePixel() es una funci√≥n que se aplica a cada pixel en la imagen, y sirve para agregar alg√∫n procesamineto a √©stos. Recibe un objeto sample, que tiene como atributos cada una de las bandas, estilo sample.B04.\nUn ejemplo de c√≥mo podemos usar este script, es para crear una capa de nubes donde √©stas las podamos marcar de color rojo. Existe una capa llamada CLM (cloud mask), que indica con un zero donde no hay nubes, con un 1 si hay nubes, y con un 255 si no hay datos. En el siguiente script agregamos esta capa a la lista en setup(), y en evaluatePixel() pintamos rojo cada vez que un pixel contenga nubes. Entonces, si hay nube, exacerbamos el rojo, si no hay nubes, devolvemos el pixel donde todas las bandas son reescalados por un factor de calibraci√≥n para visulizarlas mejor.\n\nevalscript_clm = \"\"\"\n//VERSION=3\n\nfunction setup() {\n  return {\n    input: [\"B02\", \"B03\", \"B04\", \"CLM\"],\n    output: { bands: 3 }\n  }\n}\n\nfunction evaluatePixel(sample) {\n  if (sample.CLM == 1) {\n    return [0.75 + sample.B04, sample.B03, sample.B02]\n  }\n  return [3.5*sample.B04, 3.5*sample.B03, 3.5*sample.B02];\n}\n\"\"\"\n\nAhora, podemos hacer nuestra llamada especificando algunos par√°metros importantes: - evalscript: nuestro script de javascript - data_folder: el path del directorio donde queremos guardar las im√°genes. Debemos indicar True o False cuando hagamos el request para eligir si guardaremos la imagen o no. - bbox: el bounding box que definimos - size: la dimensi√≥n de la imagen en pixeles - config: credenciales de autenticaci√≥n - input_data - data_collection: la colecci√≥n de im√°genes que vamos a llamar - time_interval: intervalo de tiempo para la b√∫squeda de la imagen - mosaicking_order: elegir las im√°genes con menos nubes\nHagamos la siguiente llamada:\n\nBandas RGB (B04, B03, B02) desde Sentinel-2 L1C\nIntervalo de tiempo entre el 1 y 30 de junio de 2020\nElijamos las imagenes con menos nubes\n\nDe vuelta vamos a obtener un array, con valores enteros entre 0 y 255.\n\n# Prepare request\nrequest_true_color = SentinelHubRequest(\n    evalscript=evalscript,\n    data_folder=\"images\",\n    input_data=[\n        SentinelHubRequest.input_data(\n            data_collection=DataCollection.SENTINEL2_L1C,\n            time_interval=(\"2020-06-01\", \"2020-06-30\"),\n            mosaicking_order=MosaickingOrder.LEAST_CC,\n        )\n    ],\n    responses=[SentinelHubRequest.output_response(\"default\", MimeType.PNG)],\n    bbox=betsiboka_bbox,\n    size=betsiboka_size,\n    config=config,\n)\n\n# Call\ntrue_color_imgs = request_true_color.get_data(save_data=False)\n\n\nprint(f\"Returned data is of type = {type(true_color_imgs)} and length {len(true_color_imgs)}.\")\nprint(f\"Single element in the list is of type {type(true_color_imgs[-1])} and has shape {true_color_imgs[-1].shape}\")\n\nReturned data is of type = &lt;class 'list'&gt; and length 1.\nSingle element in the list is of type &lt;class 'numpy.ndarray'&gt; and has shape (1047, 631, 3)\n\n\n\nimage = true_color_imgs[0]\nprint(f\"Image type: {image.dtype}\")\n\nImage type: uint8\n\n\n\nfrom typing import Any\n\ndef plot_image(\n    image: np.ndarray, \n    factor: float = 1.0, \n    clip_range: tuple[float, float] | None = None, \n    **kwargs: Any\n) -&gt; None:\n    \"\"\"Utility function for plotting RGB images.\"\"\"\n    _, ax = plt.subplots(nrows=1, ncols=1, figsize=(15, 15))\n    if clip_range is not None:\n        ax.imshow(np.clip(image * factor, *clip_range), **kwargs)\n    else:\n        ax.imshow(image * factor, **kwargs)\n    ax.set_xticks([])\n    ax.set_yticks([])\n\n\n# plot function\n# factor 1/255 to scale between 0-1\n# factor 3.5 to increase brightness\nplot_image(image, factor=3.5 / 255, clip_range=(0, 1))\n\n\n\n\n\n\n\n\nAhora, tratemos de descargar todas las bandas de Sentinel-2, para el mismo bounding box. Como ahora vamos a hacer un request de m√°s datos, necesitamos achicar la query. Una forma de hacer esto es con el par√°metro units=DN para los datos de reflectancia. Tambi√©n, settear sampleType a INT16. Finalmente, no caben todas estas capas en formato png, por lo que debe descargarse en TIFF. El script se ver√≠a as√≠:\n\nevalscript_all_bands = \"\"\"\n    //VERSION=3\n\n    function setup() {\n        return {\n            input: [{\n                bands: [\"B01\",\"B02\",\"B03\",\"B04\",\"B05\",\"B06\",\"B07\",\"B08\",\"B8A\",\"B09\",\"B10\",\"B11\",\"B12\"],\n                units: \"DN\"\n            }],\n            output: {\n                bands: 13,\n                sampleType: \"INT16\"\n            }\n        };\n    }\n\n    function evaluatePixel(sample) {\n        return [sample.B01,\n                sample.B02,\n                sample.B03,\n                sample.B04,\n                sample.B05,\n                sample.B06,\n                sample.B07,\n                sample.B08,\n                sample.B8A,\n                sample.B09,\n                sample.B10,\n                sample.B11,\n                sample.B12];\n    }\n\"\"\"\n\nY el request lo definimos as√≠:\n\nrequest_all_bands = SentinelHubRequest(\n    evalscript=evalscript_all_bands,\n    input_data=[\n        SentinelHubRequest.input_data(\n            data_collection=DataCollection.SENTINEL2_L1C,\n            time_interval=(\"2020-06-01\", \"2020-06-30\"),\n            mosaicking_order=MosaickingOrder.LEAST_CC,\n        )\n    ],\n    responses=[SentinelHubRequest.output_response(\"default\", MimeType.TIFF)], # ojo, TIFF!\n    bbox=betsiboka_bbox,\n    size=betsiboka_size,\n    config=config,\n)\n\n\nBajar multiples imagenes a lo largo de un per√≠odo de tiempo\n\nstart = datetime.datetime(2019, 1, 1)\nend = datetime.datetime(2019, 12, 31)\nn_chunks = 13\ntdelta = (end - start) / n_chunks\nedges = [(start + i * tdelta).date().isoformat() for i in range(n_chunks)]\nslots = [(edges[i], edges[i + 1]) for i in range(len(edges) - 1)]\n\nprint(\"Monthly time windows:\\n\")\nfor slot in slots:\n    print(slot)\n\n\ndef get_true_color_request(time_interval):\n    return SentinelHubRequest(\n        evalscript=evalscript_true_color,\n        input_data=[\n            SentinelHubRequest.input_data(\n                data_collection=DataCollection.SENTINEL2_L1C,\n                time_interval=time_interval,\n                mosaicking_order=MosaickingOrder.LEAST_CC,\n            )\n        ],\n        responses=[SentinelHubRequest.output_response(\"default\", MimeType.PNG)],\n        bbox=betsiboka_bbox,\n        size=betsiboka_size,\n        config=config,\n    )\n\n\n# create a list of requests\nlist_of_requests = [get_true_color_request(slot) for slot in slots]\nlist_of_requests = [request.download_list[0] for request in list_of_requests]\n\n# download data with multiple threads\ndata = SentinelHubDownloadClient(config=config).download(list_of_requests, max_threads=5)\n\n\n# some stuff for pretty plots\nncols = 4\nnrows = 3\naspect_ratio = betsiboka_size[0] / betsiboka_size[1]\nsubplot_kw = {\"xticks\": [], \"yticks\": [], \"frame_on\": False}\n\nfig, axs = plt.subplots(ncols=ncols, nrows=nrows, figsize=(5 * ncols * aspect_ratio, 5 * nrows), subplot_kw=subplot_kw)\n\nfor idx, image in enumerate(data):\n    ax = axs[idx // ncols][idx % ncols]\n    ax.imshow(np.clip(image * 2.5 / 255, 0, 1))\n    ax.set_title(f\"{slots[idx][0]}  -  {slots[idx][1]}\", fontsize=10)\n\nplt.tight_layout()\n\n\n\nTodas las capas\nComo ahora vamos a hacer un request pro m√°s datos, necesitamos achicar la query. Una forma de hacer esto es con el par√°metro units=DN para los datso de reflectancia. Tambi√©n, settear sampleType a INT16. Finalmente, no caben todas estas capas en formato png, por lo que debe descargarse en TIFF.\n\n%%time\n\nevalscript_all_bands = \"\"\"\n    //VERSION=3\n    function setup() {\n        return {\n            input: [{\n                bands: [\"B01\",\"B02\",\"B03\",\"B04\",\"B05\",\"B06\",\"B07\",\"B08\",\"B8A\",\"B09\",\"B10\",\"B11\",\"B12\"],\n                units: \"DN\"\n            }],\n            output: {\n                bands: 13,\n                sampleType: \"INT16\"\n            }\n        };\n    }\n\n    function evaluatePixel(sample) {\n        return [sample.B01,\n                sample.B02,\n                sample.B03,\n                sample.B04,\n                sample.B05,\n                sample.B06,\n                sample.B07,\n                sample.B08,\n                sample.B8A,\n                sample.B09,\n                sample.B10,\n                sample.B11,\n                sample.B12];\n    }\n\"\"\"\n\nrequest_all_bands = SentinelHubRequest(\n    evalscript=evalscript_all_bands,\n    input_data=[\n        SentinelHubRequest.input_data(\n            data_collection=DataCollection.SENTINEL2_L1C,\n            time_interval=(\"2020-06-01\", \"2020-06-30\"),\n            mosaicking_order=MosaickingOrder.LEAST_CC,\n        )\n    ],\n    responses=[SentinelHubRequest.output_response(\"default\", MimeType.TIFF)],\n    bbox=betsiboka_bbox,\n    size=betsiboka_size,\n    config=config,\n)\n\nCPU times: user 160 ¬µs, sys: 1 ¬µs, total: 161 ¬µs\nWall time: 164 ¬µs\n\n\n\nall_bands_response = request_all_bands.get_data()\n\n\nall_bands_response[0].shape\n\n(1047, 631, 13)\n\n\n\n# Image showing the SWIR band B12\n# Factor 1/1e4 due to the DN band values in the range 0-10000\n# Factor 3.5 to increase the brightness\nplot_image(all_bands_response[0][:, :, 12], factor=3.5 / 1e4, vmax=1)\n\n\n\n\n\n\n\n\n\n\nCreate time lapse\n\ndef download_and_save_image(\n    target_area_coords: tuple,\n    resolution: int,\n    year: int,\n    month: int,\n    foldout: str,\n    location_name: str,\n):\n    \"\"\"\n    Download and save an image from Sentinel Hub.\n\n    Parameters:\n    -----------\n    target_area_coords : tuple\n        Long/lat pairs for upper left and lower right vertices of bounding box.\n    resolution : int\n        Resolution of the image to be downloaded.\n    year : int\n        Year of the image.\n    month : int\n        Month of the image.\n    foldout : str\n        Path to the directory where the image will be saved.\n    location_name : str\n        Name of the location for identification.\n\n    Returns:\n    --------\n    np.ndarray\n        The downloaded image as a NumPy array.\n\n    Raises:\n    -------\n    RuntimeError\n        If the image file already exists.\n\n    \"\"\"\n    \n    # Create directory to store the images\n    if not os.path.exists(foldout):\n        os.makedirs(foldout)\n    \n    # Get month names\n    timestamp = year * 100 + month\n    frame_file  = str(timestamp) + \"_\" + location_name + \".png\"\n\n\n    if not os.path.exists(frame_file):        \n        # Define bbox\n        target_bbox = BBox(bbox=target_area_coords, crs=CRS.WGS84)\n        target_size = bbox_to_dimensions(target_bbox, resolution=resolution)\n\n        # Create query\n        evalscript_true_color = \"\"\"\n            //VERSION=3\n\n            function setup() {\n                return {\n                    input: [{\n                        bands: [\"B02\", \"B03\", \"B04\"]\n                    }],\n                    output: {\n                        bands: 3\n                    }\n                };\n            }\n\n            function evaluatePixel(sample) {\n                return [sample.B04, sample.B03, sample.B02];\n            }\n        \"\"\"\n\n        # Call API\n        date_since = str(year) + \"-\" + str(month) + \"-01\"\n        date_until = str(year) + \"-\" + str(month) + \"-28\"\n        \n        request_true_color = SentinelHubRequest(\n                    evalscript=evalscript_true_color,\n                    input_data=[\n                        SentinelHubRequest.input_data(\n                            data_collection=DataCollection.SENTINEL2_L1C,\n                            time_interval=(date_since, date_until),\n                            mosaicking_order=MosaickingOrder.LEAST_CC,\n                        )\n                    ],\n                    responses=[SentinelHubRequest.output_response(\"default\", MimeType.PNG)],\n                    bbox=target_bbox,\n                    size=target_size,\n                    config=config,\n                )\n        \n        # # Extract image RGB channels\n        # true_color_imgs = request_true_color.get_data()\n        # image = true_color_imgs[0].astype(np.uint8)\n        \n        # Extract image RGB channels\n        try:\n            true_color_imgs = request_true_color.get_data()\n        except Exception as e:\n            raise RuntimeError(f\"Failed to retrieve image data: {e}\")\n\n        image = true_color_imgs[0].astype(np.uint8)\n                \n        # Create plot and save\n        f, ax = plt.subplots(1,1,figsize=(10,10))\n        factor=2.0 / 255\n        clip_range=(0, 200)\n        ax.imshow(np.clip(image * factor, *clip_range))\n        ax.axis('off')\n        \n        ax.annotate(\n            timestamp, \n            xy=(0.0125, 0.967), \n            xycoords='axes fraction', \n            ha='left', va='center',\n            bbox=dict(boxstyle='round', alpha=0.0), \n            fontsize=26, \n            color='w'\n        )\n        plt.savefig(foldout + '/' + frame_file, dpi=200, bbox_inches='tight')\n        plt.tight_layout()\n        plt.close()\n        \n        print(f\"Image {frame_file} has been saved.\")\n        return image\n\n\n%%time\n\n# Define bbox for Embalse Puclaro\nfoldout = \"frames\"\nlocation_name = \"puclaro\"\ntarget_area_coords = (-70.86578, -29.98710, -70.80273, -30.02864)\nresolution = 10\n\n# Get images for each month of the looped years\nfor year in range(2016, 2025):\n    for month in range(1,13):    \n        if year == 2024:\n            if month &lt; 4:\n                download_and_save_image(target_area_coords, resolution, year, month, foldout, location_name)\n        else:\n            download_and_save_image(target_area_coords, resolution, year, month, foldout, location_name)\n\nClipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).\nClipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).\nClipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).\nClipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).\nClipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).\n\n\nImage 201601_puclaro.png has been saved.\nImage 201602_puclaro.png has been saved.\nImage 201603_puclaro.png has been saved.\nImage 201604_puclaro.png has been saved.\nImage 201605_puclaro.png has been saved.\nImage 201606_puclaro.png has been saved.\nImage 201607_puclaro.png has been saved.\nImage 201608_puclaro.png has been saved.\nImage 201609_puclaro.png has been saved.\nImage 201610_puclaro.png has been saved.\nImage 201611_puclaro.png has been saved.\nImage 201612_puclaro.png has been saved.\nImage 201701_puclaro.png has been saved.\nImage 201702_puclaro.png has been saved.\nImage 201703_puclaro.png has been saved.\nImage 201704_puclaro.png has been saved.\nImage 201705_puclaro.png has been saved.\nImage 201706_puclaro.png has been saved.\nImage 201707_puclaro.png has been saved.\nImage 201708_puclaro.png has been saved.\nImage 201709_puclaro.png has been saved.\nImage 201710_puclaro.png has been saved.\nImage 201711_puclaro.png has been saved.\nImage 201712_puclaro.png has been saved.\nImage 201801_puclaro.png has been saved.\nImage 201802_puclaro.png has been saved.\nImage 201803_puclaro.png has been saved.\nImage 201804_puclaro.png has been saved.\nImage 201805_puclaro.png has been saved.\nImage 201806_puclaro.png has been saved.\nImage 201807_puclaro.png has been saved.\nImage 201808_puclaro.png has been saved.\nImage 201809_puclaro.png has been saved.\nImage 201810_puclaro.png has been saved.\nImage 201811_puclaro.png has been saved.\nImage 201812_puclaro.png has been saved.\nImage 201901_puclaro.png has been saved.\nImage 201902_puclaro.png has been saved.\nImage 201903_puclaro.png has been saved.\nImage 201904_puclaro.png has been saved.\nImage 201905_puclaro.png has been saved.\nImage 201906_puclaro.png has been saved.\nImage 201907_puclaro.png has been saved.\nImage 201908_puclaro.png has been saved.\nImage 201909_puclaro.png has been saved.\nImage 201910_puclaro.png has been saved.\nImage 201911_puclaro.png has been saved.\nImage 201912_puclaro.png has been saved.\nImage 202001_puclaro.png has been saved.\nImage 202002_puclaro.png has been saved.\nImage 202003_puclaro.png has been saved.\nImage 202004_puclaro.png has been saved.\nImage 202005_puclaro.png has been saved.\nImage 202006_puclaro.png has been saved.\nImage 202007_puclaro.png has been saved.\nImage 202008_puclaro.png has been saved.\nImage 202009_puclaro.png has been saved.\nImage 202010_puclaro.png has been saved.\nImage 202011_puclaro.png has been saved.\nImage 202012_puclaro.png has been saved.\nImage 202101_puclaro.png has been saved.\nImage 202102_puclaro.png has been saved.\nImage 202103_puclaro.png has been saved.\nImage 202104_puclaro.png has been saved.\nImage 202105_puclaro.png has been saved.\nImage 202106_puclaro.png has been saved.\nImage 202107_puclaro.png has been saved.\nImage 202108_puclaro.png has been saved.\nImage 202109_puclaro.png has been saved.\nImage 202110_puclaro.png has been saved.\nImage 202111_puclaro.png has been saved.\nImage 202112_puclaro.png has been saved.\nImage 202201_puclaro.png has been saved.\nImage 202202_puclaro.png has been saved.\nImage 202203_puclaro.png has been saved.\nImage 202204_puclaro.png has been saved.\nImage 202205_puclaro.png has been saved.\nImage 202206_puclaro.png has been saved.\nImage 202207_puclaro.png has been saved.\nImage 202208_puclaro.png has been saved.\nImage 202209_puclaro.png has been saved.\nImage 202210_puclaro.png has been saved.\nImage 202211_puclaro.png has been saved.\nImage 202212_puclaro.png has been saved.\nImage 202301_puclaro.png has been saved.\nImage 202302_puclaro.png has been saved.\nImage 202303_puclaro.png has been saved.\nImage 202304_puclaro.png has been saved.\nImage 202305_puclaro.png has been saved.\nImage 202306_puclaro.png has been saved.\nImage 202307_puclaro.png has been saved.\nImage 202308_puclaro.png has been saved.\nImage 202309_puclaro.png has been saved.\nImage 202310_puclaro.png has been saved.\nImage 202311_puclaro.png has been saved.\nImage 202312_puclaro.png has been saved.\nImage 202401_puclaro.png has been saved.\nImage 202402_puclaro.png has been saved.\nImage 202403_puclaro.png has been saved.\nCPU times: user 1min 19s, sys: 4.73 s, total: 1min 24s\nWall time: 9min 53s\n\n\nEnsemble images as animation\n\nfrom PIL import Image\n\npng_files = [f for f in os.listdir(foldout) if f.endswith('.png')]\npng_files.sort()\nframes = []\n\nfor png_file in png_files:\n    file_path = os.path.join(foldout, png_file)\n    img = Image.open(file_path)\n    frames.append(img)\n\noutput_gif_path = 'footage_complete.gif'\n\nframes[0].save(\n    output_gif_path,\n    save_all=True,\n    append_images=frames[1:],\n    duration=200,  # Set the duration between frames in milliseconds\n    loop=1         # Set loop to 0 for an infinite loop, or any positive integer for a finite loop\n)\n\n['201602_puclaro.png',\n '201603_puclaro.png',\n '201607_puclaro.png',\n '201608_puclaro.png',\n '201609_puclaro.png',\n '201611_puclaro.png',\n '201612_puclaro.png',\n '201701_puclaro.png',\n '201702_puclaro.png',\n '201703_puclaro.png',\n '201704_puclaro.png',\n '201705_puclaro.png',\n '201706_puclaro.png',\n '201707_puclaro.png',\n '201708_puclaro.png',\n '201709_puclaro.png',\n '201710_puclaro.png',\n '201711_puclaro.png',\n '201712_puclaro.png',\n '201801_puclaro.png',\n '201802_puclaro.png',\n '201803_puclaro.png',\n '201804_puclaro.png',\n '201805_puclaro.png',\n '201806_puclaro.png',\n '201807_puclaro.png',\n '201808_puclaro.png',\n '201809_puclaro.png',\n '201810_puclaro.png',\n '201811_puclaro.png',\n '201812_puclaro.png',\n '201901_puclaro.png',\n '201902_puclaro.png',\n '201903_puclaro.png',\n '201904_puclaro.png',\n '201905_puclaro.png',\n '201906_puclaro.png',\n '201907_puclaro.png',\n '201908_puclaro.png',\n '201909_puclaro.png',\n '201910_puclaro.png',\n '201911_puclaro.png',\n '201912_puclaro.png',\n '202001_puclaro.png',\n '202002_puclaro.png',\n '202003_puclaro.png',\n '202005_puclaro.png',\n '202006_puclaro.png',\n '202007_puclaro.png',\n '202008_puclaro.png',\n '202009_puclaro.png',\n '202010_puclaro.png',\n '202011_puclaro.png',\n '202012_puclaro.png',\n '202101_puclaro.png',\n '202102_puclaro.png',\n '202103_puclaro.png',\n '202104_puclaro.png',\n '202105_puclaro.png',\n '202106_puclaro.png',\n '202107_puclaro.png',\n '202108_puclaro.png',\n '202109_puclaro.png',\n '202110_puclaro.png',\n '202111_puclaro.png',\n '202112_puclaro.png',\n '202201_puclaro.png',\n '202202_puclaro.png',\n '202203_puclaro.png',\n '202204_puclaro.png',\n '202205_puclaro.png',\n '202206_puclaro.png',\n '202207_puclaro.png',\n '202208_puclaro.png',\n '202209_puclaro.png',\n '202210_puclaro.png',\n '202211_puclaro.png',\n '202212_puclaro.png',\n '202301_puclaro.png',\n '202302_puclaro.png',\n '202303_puclaro.png',\n '202304_puclaro.png',\n '202305_puclaro.png',\n '202306_puclaro.png',\n '202307_puclaro.png',\n '202308_puclaro.png',\n '202309_puclaro.png',\n '202310_puclaro.png',\n '202311_puclaro.png',\n '202312_puclaro.png',\n '202401_puclaro.png',\n '202402_puclaro.png',\n '202403_puclaro.png']\n\n\nAdd crossfading between frames\n\n%%time \n\nfrom PIL import Image, ImageDraw\n\npng_files = [f for f in os.listdir(foldout) if f.endswith('.png')]\npng_files.sort()\nframes = []\n\nfor png_file in png_files:\n    file_path = os.path.join(foldout, png_file)\n    img = Image.open(file_path)\n    frames.append(img)\n\n# Define the duration for each frame in milliseconds\nframe_duration = 60\n\n# Define the number of frames for the crossfade transition\ncrossfade_frames = 6\n\n# Create a list to store the crossfaded frames\ncrossfaded_frames = []\n\n# Iterate through pairs of consecutive frames\nfor i in range(len(frames) - 1):\n    # Extract current and next frames\n    current_frame = frames[i]\n    next_frame = frames[i + 1]\n\n    # Create a sequence of crossfaded frames between the current and next frames\n    for j in range(crossfade_frames + 1):\n        # Calculate the alpha value for blending\n        alpha = j / crossfade_frames\n\n        # Blend the current and next frames using alpha blending\n        blended_frame = Image.blend(current_frame, next_frame, alpha)\n\n        # Append the blended frame to the list of crossfaded frames\n        crossfaded_frames.append(blended_frame)\n\n# Add the last frame without crossfading\ncrossfaded_frames.append(frames[-1])\noutput_gif_path = 'footage_complete_2.gif'\n\n# Save the GIF with crossfaded frames\ncrossfaded_frames[0].save(\n    output_gif_path,\n    save_all=True,\n    append_images=crossfaded_frames[1:],\n    duration=frame_duration,  # Set the duration between frames in milliseconds\n    loop=0  # Set loop to 0 for an infinite loop, or any positive integer for a finite loop\n)\n\nCPU times: user 37.5 s, sys: 2.34 s, total: 39.8 s\nWall time: 40.8 s"
  }
]